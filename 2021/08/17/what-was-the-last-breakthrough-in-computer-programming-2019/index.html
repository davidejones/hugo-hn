<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.87.0" />



<link rel="canonical" href="https://davidejones.github.io/hugo-hn/2021/08/17/what-was-the-last-breakthrough-in-computer-programming-2019/">


    <title>What was the last breakthrough in computer programming? (2019) - Hugo Hacker News</title>
    
<meta name="description" content="">

<meta property="og:title" content="What was the last breakthrough in computer programming? (2019) - Hugo Hacker News">
<meta property="og:type" content="article">
<meta property="og:url" content="https://davidejones.github.io/hugo-hn/2021/08/17/what-was-the-last-breakthrough-in-computer-programming-2019/">
<meta property="og:image" content="https://davidejones.github.io/hugo-hn/images/default.png">
<meta property="og:site_name" content="Hugo Hacker News">
<meta property="og:description" content="">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="Hugo Hacker News">
<meta name="twitter:url" content="https://davidejones.github.io/hugo-hn/2021/08/17/what-was-the-last-breakthrough-in-computer-programming-2019/">
<meta name="twitter:title" content="What was the last breakthrough in computer programming? (2019) - Hugo Hacker News">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://davidejones.github.io/hugo-hn/images/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"https:\/\/davidejones.github.io\/hugo-hn\/"
    },
    "headline": "What was the last breakthrough in computer programming? (2019) - Hugo Hacker News",
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/davidejones.github.io\/hugo-hn\/images\/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2021-08-17T14:22:59JST",
    "dateModified": "2021-08-17T14:22:59JST",
    "author": {
      "@type": "Person",
      "name": "Hugo Hacker News"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Hugo Hacker News",
      "logo": {
        "@type": "ImageObject",
        "url": "https:\/\/davidejones.github.io\/hugo-hn\/images/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": ""
  }
</script>



    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">

    
    
    
    
        
    
    
    <link href="https://davidejones.github.io/hugo-hn/style.min.130df59cea3bafd8a515eeb4a51c215616cb41f2a9520765b9f1574d3cfedf2c485abb4a8d785adcd7acdc2400797ba6abffe5b0bb4612cb79bc0b884aac89e8.css" rel="stylesheet" />
</head>
<body class="post">
    <header>
        <a href="https://davidejones.github.io/hugo-hn/">Hugo Hacker News</a>
        <nav>
            <ul>
                
                    <li><a href="/hugo-hn/">new</a></li>
                
                    <li><a href="/hugo-hn/comments/">comments</a></li>
                
                    <li><a href="/hugo-hn/categories/show/">show</a></li>
                
                    <li><a href="/hugo-hn/categories/ask/">ask</a></li>
                
                    <li><a href="/hugo-hn/categories/jobs/">jobs</a></li>
                
                    <li><a href="https://news.ycombinator.com/submit">submit</a></li>
                
            </ul>
        </nav>
        <select onchange="myChangeHandler(this)">
            
                <option value="/hugo-hn/">new</option>
            
                <option value="/hugo-hn/comments/">comments</option>
            
                <option value="/hugo-hn/categories/show/">show</option>
            
                <option value="/hugo-hn/categories/ask/">ask</option>
            
                <option value="/hugo-hn/categories/jobs/">jobs</option>
            
                <option value="https://news.ycombinator.com/submit">submit</option>
            
        </select>
    </header>
    <main>
        
<article>
    <header>
        <h1><a href="https://www.quora.com/What-was-the-last-breakthrough-in-computer-programming/answer/Alan-Kay-11?share=1">What was the last breakthrough in computer programming? (2019)</a></h1>
        
    </header>
    
        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=karmakaze" target="_blank">karmakaze</a>   <span class="timeago" data-date="2021-08-17 15:08:10 &#43;0000 UTC">2021-08-17 15:08:10 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            There isn&#x27;t so much in languages features themselves, but in their implementations. GC can be largely pauseless for many practical purposes and a GC language can be within 2x-3x the performance of C-like languages.<p>Also the amount&#x2F;cost of memory has improved so that we can use immutable datastructures and functional style in many contexts, which definitely feels like a &#x27;level-up&#x27;.<p>Concurrency has been getting easier too, with many languages supporting coroutines&#x2F;async and&#x2F;or threads. Reference capabilities are exciting as in Pony, Rust, or Clean.<p>In general there&#x27;s a great convergence where ergonomics are improving (editors, compilers, build&#x2F;package systems) and each language evolves to adopt features of other languages.<p>I just dabbled into the Sorbet type checker after not writing any C++ since the 90s, and it was surprisingly browseable&#x2F;readable and could copy&#x2F;paste the concepts based on recent Ruby, Java&#x2F;Go knowledge.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-17 15:56:40 &#43;0000 UTC">2021-08-17 15:56:40 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It&#x27;s nice to read a positive comment like yours occasionally, because the vast majority of the time, I&#x27;m just disappointed in how bad our programming tools (including languages) are.<p>It&#x27;s become a meme in my office that I&#x27;m the guy constantly bitching about how stupid our languages are. This week I was back on my soap box about the fact that almost zero mainstream (statically typed) programming languages can even let you write down that you want a non-empty string. In some languages you can implement your own class&#x2F;type that wraps around the built-in string type, but most of the time you are now introducing memory and CPU overhead, can&#x27;t use your type with other APIs that expect strings, etc. So nobody does that. But ask yourself this: how often have you ever written a function that requested a string as input and actually wanted an empty string? How many times did you not even think about what would happen if someone DID pass an empty string?<p>Same goes for positive and non-negative numbers. How many times did you write &quot;int&quot; when you actually only wanted a positive number? If I have to type &quot;if x &lt;= 0 throw FooException&quot; as the first line of one more function, I&#x27;m going to scream. (A lot of languages do have unsigned ints, to be fair. But some still don&#x27;t, or their unsigned ints are almost useless.)<p>People make all kinds of Stockholm Syndrome-y excuses for it (&quot;validate inputs at the edges is all you need&quot;), but the truth is that (most of) our languages are so deficient for expressing really basic ideas.<p>Thank goodness there are some languages that do try to make it possible to write &quot;newtypes&quot; and try to make concurrency safer. Now if we could just get everyone to adopt those in less than a decade, maybe we&#x27;d be able to get to the next generation after that, and then maybe we&#x27;ll have good programming languages before I die.<p>Sorry that turned into a rant... :&#x2F;
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-17 20:05:24 &#43;0000 UTC">2021-08-17 20:05:24 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I&#x27;m not so sure that I sympathize with your example.  Why not a type for even numbers?  Odd, prime, not-prime, etc?<p>You really are asking for a type that is &quot;valid data.&quot;  Commendable, but not a static property of data.  As a fun example, what is a valid email address?  Once established as valid, how long will it stay that way?  If invalid, how long until it can become valid?<p>Do I think better typing can be a boon?  Absolutely!  Can it also be a burden?  Absolutely!
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=WalterBright" target="_blank">WalterBright</a>   <span class="timeago" data-date="2021-08-17 21:02:03 &#43;0000 UTC">2021-08-17 21:02:03 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; Why not a type for even numbers? Odd, prime, not-prime, etc?<p>Why not indeed? See my other comment <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28214776" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28214776</a> about how to create such types.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-17 21:27:02 &#43;0000 UTC">2021-08-17 21:27:02 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I meant that line as a bit of a tease to other tricks.<p>And it isn&#x27;t like this isn&#x27;t done often.  Take the lowly format string in c languages.  With the requirement that the format string has to be static, it is common to fail builds if you give it a bad format string or supply the wrong number of arguments.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=DennisP" target="_blank">DennisP</a>   <span class="timeago" data-date="2021-08-17 20:55:28 &#43;0000 UTC">2021-08-17 20:55:28 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Dependent typing can do that sort of thing. In fact, here&#x27;s a stackoverflow answer that uses even numbers as an example of a dependent type: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;9338709&#x2F;what-is-dependent-typing" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;9338709&#x2F;what-is-dependen...</a>
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-17 21:22:19 &#43;0000 UTC">2021-08-17 21:22:19 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Right.  And I look forward to advances in them.  I can count how many times this would have actually helped my program, though...
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=exdsq" target="_blank">exdsq</a>   <span class="timeago" data-date="2021-08-17 22:06:13 &#43;0000 UTC">2021-08-17 22:06:13 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Why do you think that? It might require a different mental model of types in order to see the benefits but I can&#x27;t believe anyone is working on a project that doesn&#x27;t have any sort of properties or &#x27;business&#x27; logic that dependent types wouldn&#x27;t help encode. Have you read anything about type-driven development? <a href="https:&#x2F;&#x2F;blog.ploeh.dk&#x2F;2015&#x2F;08&#x2F;10&#x2F;type-driven-development&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.ploeh.dk&#x2F;2015&#x2F;08&#x2F;10&#x2F;type-driven-development&#x2F;</a>
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-17 23:17:37 &#43;0000 UTC">2021-08-17 23:17:37 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I didn&#x27;t mean for that to read as dismissive as it clearly does.  Should have waited till I had more to say.  :)<p>I don&#x27;t think the number of places dependent typing could have helped me is zero.  Just like linear typing is nice.  I just know that many of the dependencies I work with are much more dynamic in nature, such that getting them in static types has tough ROI to justify.<p>Bluntly, the hardest program failures I&#x27;ve ever seen have been second systems from people learning generics and higher kinded types.  I&#x27;m convinced these techniques are worth learning.  I&#x27;m not convinced that they provide the immediate return on effort that they are usually sold with.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=exdsq" target="_blank">exdsq</a>   <span class="timeago" data-date="2021-08-18 02:49:52 &#43;0000 UTC">2021-08-18 02:49:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            That&#x27;s fair, I somewhat agree - especially regarding the ROI to begin with :)
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Akronymus" target="_blank">Akronymus</a>   <span class="timeago" data-date="2021-08-18 07:50:45 &#43;0000 UTC">2021-08-18 07:50:45 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Edit: It seems I confused dependant and algebraic types.<p>Wouldn&#x27;t you love the compiler giving an error when you write something that could result in illegal state? (Business rule violations for example) This is where such types shine.  <a href="https:&#x2F;&#x2F;fsharpforfunandprofit.com&#x2F;posts&#x2F;designing-with-types-making-illegal-states-unrepresentable&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fsharpforfunandprofit.com&#x2F;posts&#x2F;designing-with-types...</a>
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-18 14:28:46 &#43;0000 UTC">2021-08-18 14:28:46 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I actually meant my &quot;looking forward&quot; to be sincere.  I&#x27;ve used tooling that can point out exactly where an injection attack is possible, and that was quite nice.  That said, u expect more of these tricks in my tooling, not necessarily cuffed by me.<p>Elsewhere I pointed to format strings checked at compile time for valid shape and arguments.  This is actually common in lisps, ironically enough, and is akin to this sort of affordance.<p>I have just also seen too many projects fail that thought they could get it all in the types.  It is very frustrating.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Akronymus" target="_blank">Akronymus</a>   <span class="timeago" data-date="2021-08-18 16:00:47 &#43;0000 UTC">2021-08-18 16:00:47 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It was more because of the, what I thought, was &quot;counting on one hand&quot;. Seems like my brain tricked me.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-18 19:19:40 &#43;0000 UTC">2021-08-18 19:19:40 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I make no defence of how trite my post was.  I definitely worded it in a poor way.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=simonh" target="_blank">simonh</a>   <span class="timeago" data-date="2021-08-17 22:10:26 &#43;0000 UTC">2021-08-17 22:10:26 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            That’s easy, a valid email address is one that is well formed, conforming to the specification for email addresses.<p>I know what you’re trying to get at, but that’s just a category error. It’s a misuse of the term valid in this context. For example my mail archive contains many emails from valid addresses for which there happens to be no currently active mail box end point. They’re still valid data though. The fact that people sometimes use th s term valid to mean something completely different is just an unfortunate linguistic accident, but its a mistake to think it’s meaningful.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 22:22:58 &#43;0000 UTC">2021-08-17 22:22:58 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; conforming to the specification for email addresses<p>You mean something that roughly matches this obvious regex:<p><pre><code>  \A(?:[a-z0-9!#$%&amp;&#x27;*+&#x2F;=?^_‘{|}~-]+(?:\.[a-z0-9!#$%&amp;&#x27;*+&#x2F;=?^_‘{|}~-]+)*
   |  &quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]
        |  \\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)
  @ (?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?
    |  \[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
         (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:
            (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]
            |  \\[\x01-\x09\x0b\x0c\x0e-\x7f])+)
       \])\z
</code></pre>
[ Source: <a href="https:&#x2F;&#x2F;www.regular-expressions.info&#x2F;email.html" rel="nofollow">https:&#x2F;&#x2F;www.regular-expressions.info&#x2F;email.html</a> ]<p>That somehow doesn&#x27;t look &quot;easy&quot; on my eyes. I&#x27;m not sure the parent&#x27;s comment was serous.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Risord" target="_blank">Risord</a>   <span class="timeago" data-date="2021-08-17 23:06:59 &#43;0000 UTC">2021-08-17 23:06:59 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Thats propably because you are looking inlined assembly of definition. If you name and reuse all the partial patterns it become much more clear. Though regex is cool obfuscation method.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 23:20:49 &#43;0000 UTC">2021-08-17 23:20:49 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It would be than at least 3&#x2F;4 of a page long I guess.<p>The fun part is this is not even the full truth. As the list of TLD isn&#x27;t very static any more it&#x27;s additionally difficult to determine whether a host name is valid. That is only possible with some dynamic list (or a regex that would grow indefinitely and ever change). The presented solution doesn&#x27;t even take this into account.<p>The source page I&#x27;ve linked is a quite interesting read on that whole topic.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Risord" target="_blank">Risord</a>   <span class="timeago" data-date="2021-08-17 23:41:23 &#43;0000 UTC">2021-08-17 23:41:23 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            You propably would want to reuse referenced definitions like domain and IP which are not email specific. But yes all of our JS could be much shorter if we used APL but most of us like readability :P<p>I kind of not get why TLD should be validated. Does it matter anymore than if sub domain is not registered of if IP is not reachable. I think valid as potentially deliverable and actually deliverable should be distincted (like well formed XML and schema validated XML).
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-18 00:05:50 &#43;0000 UTC">2021-08-18 00:05:50 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The TLD part matters as some part of the email format is defined through the format of a <i>valid</i> host name. &quot;something.com&quot; is a valid host name, but &quot;something.something&quot; isn&#x27;t currently a valid host name. So an email address &quot;something@something.something&quot; isn&#x27;t a valid email address (currently).<p>But at the end of the day this is all moot, imho. The &quot;only&quot; sane test to check the validity of an email address when someone shows you one is whether you can successfully deliver mail there.<p>Because even an address is formally valid doesn&#x27;t mean it will get accepted by all systems on it&#x27;s way. Almost nobody follows the under specified, confusing, and contradictory specs to the letter.<p>That was my point in the first place: Trying to validate email addresses is a rabbit hole. It&#x27;s for sure everything, but not &quot;simple&quot;, as claimed above.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=simonh" target="_blank">simonh</a>   <span class="timeago" data-date="2021-08-18 09:05:49 &#43;0000 UTC">2021-08-18 09:05:49 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The point I was making is that whether or not you can successfully deliver email is not a sensible test of the validity of an email address, looking at the address purely as data. As I pointed out, my email archive contains many email addresses that are no longer ‘valid’ by your definition, but they are still valid as data.<p>By your definition email address validity changes literally on a moment to moment basis. Addresses are becoming invalid constantly and new ones are becoming valid constantly. It’s not a useful definition of validity, and not even something you can test meaningfully.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-18 14:47:55 &#43;0000 UTC">2021-08-18 14:47:55 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I&#x27;ve got your point already before and I think it&#x27;s valid.<p>That&#x27;s why I&#x27;ve formulated my &quot;definition&quot; carefully:<p>&gt; the validity of an email address <i>when someone shows you one</i><p>It&#x27;s of course not a &quot;definition&quot; someone could write down into a spec. But It&#x27;s by far the best &quot;informal validity check&quot; in practice. It checks whether an email address is <i>currently</i> valid. You practically can&#x27;t do more anyway!<p>The &quot;formal validity&quot; of an email address changes with time nowadays as I&#x27;ve pointed out: It depends directly on the formal validity of the host name part which can change over time given the fact that the list of TLDs changes over time (which wasn&#x27;t the case at the time those specs have been written; fun fact: there is more than one spec, and they&#x27;re contradicting each other).<p>To add on that there are two more important aspects: Firstly an email address you can&#x27;t send mail to is mostly worthless in practice as it can&#x27;t be used for its <i>primary purpose</i>. Secondly even perfectly &quot;valid&quot; addresses (by the spec) aren&#x27;t accepted by a lot of parties that claim to handle email addresses! I guess <i>a lot</i> of systems would for example refuse an address looking like &quot;-@-&quot;, wouldn&#x27;t they? But it&#x27;s perfectly valid!<p><a href="http:&#x2F;&#x2F;sphinx.mythic-beasts.com&#x2F;~pdw&#x2F;cgi-bin&#x2F;emailvalidate" rel="nofollow">http:&#x2F;&#x2F;sphinx.mythic-beasts.com&#x2F;~pdw&#x2F;cgi-bin&#x2F;emailvalidate</a><p><a href="http:&#x2F;&#x2F;www.ex-parrot.com&#x2F;~pdw&#x2F;Mail-RFC822-Address.html" rel="nofollow">http:&#x2F;&#x2F;www.ex-parrot.com&#x2F;~pdw&#x2F;Mail-RFC822-Address.html</a><p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;5090272&#x2F;can-anyone-explain-this-regular-expression-to-me-in-detail&#x2F;5092776" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;5090272&#x2F;can-anyone-expla...</a><p>We&#x27;re moving in circles by now…<p>My initial argument was that claiming that it&#x27;s &quot;easy&quot; to validated email addresses is wrong in multiple dimensions. In fact it&#x27;s one of the more complicated questions out there (given the tragedy of the specs).
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=scns" target="_blank">scns</a>   <span class="timeago" data-date="2021-08-18 05:19:43 &#43;0000 UTC">2021-08-18 05:19:43 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            OT but i like your username.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-18 00:02:24 &#43;0000 UTC">2021-08-18 00:02:24 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Why is that valid?  You already introduced a new term for this concept, well formed.<p>Amusingly, this distinction constantly annoys me with contact managers.  I don&#x27;t want to change my friend&#x27;s phone number to the new one.  I want to mark the old one as no longer active, and add the new one.  Similar for deceased family.<p>Back to the point, you seem to want null punning for the empty string.  But you still need to check for validity of the value when it is not empty.  What does that really gain you?
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 00:44:38 &#43;0000 UTC">2021-08-18 00:44:38 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            So... why NOT a type for even numbers? Or prime numbers?<p>I&#x27;m not asking for someone to supply these things in the standard library of $FOOLANG. I&#x27;m saying that very few languages offer the tools to define such things without it being very cumbersome and often incurring significant runtime overhead.<p>I know it&#x27;s possible to do better because I&#x27;ve read up a bit on Ada. I&#x27;ve used Rust and written my own &quot;newtypes&quot; with the Deref &quot;trick&quot;. I&#x27;ve toyed with Haskell.<p>So, yeah, please let me define a &quot;PrimeInt&quot; type!
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-18 05:16:35 &#43;0000 UTC">2021-08-18 05:16:35 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            My point was that focusing on an empty string as the hill to die on was a touch artificial.<p>My argument for why not, is that I don&#x27;t think it pays off for most uses.  You will wind up putting a ton of logic into the types, but then you have to do a ton of logic to correctly serialize  into the types you have.<p>Do I think there are times&#x2F;places this could pay off?  I&#x27;d hope&#x2F;expect so.  But where the data hits the wire is likely not where you can set many of these constraints such that your type system can really help with them.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 14:24:46 &#43;0000 UTC">2021-08-18 14:24:46 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; My point was that focusing on an empty string as the hill to die on was a touch artificial.<p>There must be a term for this phenomenon. My original reply that sparked this thread could be tl;dr as &quot;I get frustrated with most programming languages. People at work know me as the guy that always complains about programming languages. One example of that is that I recently complained about most languages making it hard to statically guarantee that an input string is non-empty.&quot;<p>But then I get painted as &quot;dying on a hill&quot; for non-empty strings. It was one example, and it&#x27;s not even the most important complaint I have about current programming languages. It was just one that came up this week at work because we literally had to deal with a bug from a REST API of a big company because THEY sent an empty string in a JSON payload that isn&#x27;t supposed to be empty. Their code obviously missed a check somewhere and instead of sending a 404 response, they sent a bad payload (according to their own docs).<p>&gt; My argument for why not, is that I don&#x27;t think it pays off for most uses. You will wind up putting a ton of logic into the types, but then you have to do a ton of logic to correctly serialize into the types you have.
&gt; 
&gt; Do I think there are times&#x2F;places this could pay off? I&#x27;d hope&#x2F;expect so. But where the data hits the wire is likely not where you can set many of these constraints such that your type system can really help with them.<p>This is hard to debate because we&#x27;re speaking in very abstract terms. Obviously different domains will have different needs, etc.<p>So, unfortunately, I&#x27;m not sure I follow your argument for &quot;why not&quot;. But here&#x27;s my argument for &quot;why&quot;. A lot of times, when we design software, it ends up working in &quot;layers&quot;. Some function calls some other function calls some other function, etc.<p>If that &quot;bottom&quot; function requires something like a non-empty string (maybe that function is going to print a mailing label and it would be ridiculous to waste printer time on a blank label), you have two options: compile time enforcement or runtime enforcement.<p>In my experience, the majority of the time, &quot;we&quot; choose runtime enforcement, even in statically typed languages. What does runtime enforcement look like? Usually it&#x27;s one of two things: you throw an exception or you return some kind of failure value.<p>If you throw an exception, it bubbles all the way up and your top level main loop has to catch it and understand how to handle it. That somewhat implies that your top level has to know everything that could go wrong at any layer of your code.<p>In addition, you now have a dilemma. You know that if you pass an empty-string through, that you&#x27;ll eventually hit the function that requires a non-empty string. So you have two sub-options for this option. You can validate at the top level and pass it only if it&#x27;s valid, or you can pass everything through and potentially do a lot of computational work before hitting the failing function and throwing away all that work. Most people choose to validate at the top level. So, you&#x27;re validating at the top level <i>anyway</i>, and you&#x27;re possibly validating in TWO places (the function doesn&#x27;t know who might call it)- not DRY.<p>Other issues with the (unchecked) exception approach: It ALSO means that the type signature on your bottom-layer function is LYING. It &quot;said&quot; that you could pass it a string and it would return Whatever. It was wrong. You passed a string and instead of returning a Whatever, it started unwinding the stack for you. That&#x27;s not static typing. Callers of this function can&#x27;t trust its type signature to be complete. Instead they now have to read documentation (hopefully you wrote some). But if they already have to read documentation to understand what your function accepts and returns, why did we bother write the types at all? Just use Python or JavaScript and don&#x27;t put types on anything. You just have to read the docs to know how to call it and the types will never get in the way.<p>The other runtime option is that your function might return a value that indicates failure. Some languages have &quot;Result&quot; or &quot;Try&quot; types. But if you do that, then the function that calls that bottom function has to handle the return value. There&#x27;s a good chance that the &quot;second layer&quot; function can&#x27;t really handle the failure, so it ALSO has to return a failure value. Etc, etc, until every function in the call chain has altered its return type to indicate that it may fail. Then your top level loop inspects the return value and handles the failure. I include Java-style checked exceptions in this category and not in the above &quot;exception&quot; category.<p>This return-failure-value approach pollutes all layers of your code even worse than if you just had a NonEmptyString type! Instead of the top level inspecting the bubbled up failure value after doing a bunch of computation, it <i>could</i> have just tried creating a NonEmptyString type from the input. If it failed, then the top-level handles the failure same as before, but didn&#x27;t waste a bunch of CPU and clock time doing computations before hitting the failure. Furthermore, it&#x27;s very DRY because the validation logic is in the type itself, either in some kind of type refinement mechanism, or in a factory function, etc.<p>Furthermore, the NonEmptyString type approach gives you more compile-time safety from bugs. If you try to call that bottom function with a maybe-empty-string, it won&#x27;t compile. In the other cases, you&#x27;ll only find out at runtime, even though you KNOW ahead of time that it&#x27;s illegal to do so. I hope your tests cover everything.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-18 14:48:17 &#43;0000 UTC">2021-08-18 14:48:17 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            First, an ack that I am almost certainly not touching all of your points.  My apologies on that.<p>I think I am going to lean in on our arguments.  I would rather change mine from &quot;why not&quot; to &quot;why this isn&#x27;t worth forcing&quot;.<p>That is, on the logic and aims, I fully agree with you.  It is more that in practice, I have seen this fail too many times.  I expect and look forward to it succeeding some day, but I still caution against jumping all in.<p>I should also ack that I am pretty happy with how common lisp does this.  By mixing in read time and evaluation time, you can actually get a lot of this.  I&#x27;m on my phone right now, but (format nil &quot;~{&quot;) will not evaluate in sbcl.  Instead, it will indicate an error in the format string.  This is similar to how c will fail the build with Wall and Werror on similar bad format strings.  Difference is that in lisp, you can add such evaluation time checks as a user.<p>As for why we do so much at runtime, my assertion is we check at runtime that which is determined at runtime.  When getting data from outside the static program, there is little help the static type system can offer.  So, deep in your system, get things out of strings and primitives as soon as you can.  Don&#x27;t pass a string username, pass a username.  This gets you essentially what you want, but flags where the invalid value could have come from, as well as where it could have been used.  And lets you add on other validations.  AuthenticatedUsername and UnauthenticatedUsername, for example.<p>I get that you called those out as another category of error, but types are explicitly for that, as well.<p>And finally, in somewhat reverse form, I agree that arguments on specifics as a proxy for general are frustrating.  For my part, apologies on adding to it.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=hnfong" target="_blank">hnfong</a>   <span class="timeago" data-date="2021-08-18 15:49:06 &#43;0000 UTC">2021-08-18 15:49:06 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Type checking is not a panacea. You cannot use type checking to spot and fix all bugs.<p>Funny enough the problem you raised was trivially solvable by creating a BNF-like checker based on the spec for &quot;THEIR&quot; API response data.<p>YOU just didn&#x27;t want to do it.<p>I&#x27;m pretty sure there are solutions at least in C++ and Java (eg. validate at the edge and convert it into a ValidatedString type and use this type throughout), but honestly, you seem like the type that complains about missing incoherent features that can be trivially resolved (and not recognizing that the &quot;imperfect&quot; parts being an inherent part of the problem as opposed to being a deficiency in tooling), so I&#x27;ll just leave my comment at that.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 16:38:01 &#43;0000 UTC">2021-08-18 16:38:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt;  Type checking is not a panacea. You cannot use type checking to spot and fix all bugs.<p>I didn&#x27;t say it was or it could.<p>&gt; Funny enough the problem you raised was trivially solvable by creating a BNF-like checker based on the spec for &quot;THEIR&quot; API response data.
&gt; 
&gt; YOU just didn&#x27;t want to do it.<p>I didn&#x27;t write the code, but if I did, I WOULD have used a NonEmptyString type for the deserialized result of the response body. That&#x27;s... pretty much my whole freaking point here.<p>The &quot;problem&quot; is that my colleagues, as well as many, many, devs, including the ones at the company in question, are going to do the easiest thing they can. If your language provides String, and writing your own NonEmptyString type would require a bunch of boilerplate, most devs are just not gonna do it. &quot;We&#x27;ll never have an empty string here, anyway&quot; they&#x27;ll say. Until they do.<p>And, as I pointed out in another comment, I DO write these types in languages like Java. It&#x27;s a ton of boilerplate and the language fights you at every turn. In Java, most texty APIs expect a String instance, which is a final class. So I have to wrap String with my class and convert to-and-from explicitly all over my code. Not to mention the performance overhead and optimization loss from wrapping a primitive type.<p>So, thanks for the condescending attitude, but I DO put my money where my mouth is and I still feel completely justified in criticizing the current state of software development tools.<p>If our tools and &quot;best practices&quot; are adequate, then how in the hell did Apple, a trillion dollar company, just release a version of macOS a year ago that literally had a calculator app that gave the wrong arithmetic answer if you used it too quickly?!<p>Every time I criticize software dev stuff and someone replies and tells me everything is totally fine, it only makes me stronger.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=hnfong" target="_blank">hnfong</a>   <span class="timeago" data-date="2021-08-18 17:06:01 &#43;0000 UTC">2021-08-18 17:06:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; I WOULD have used a NonEmptyString type for the deserialized result of the response body. That&#x27;s... pretty much my whole freaking point here<p>Huh, you rambled about not being able to do so. But now you claim it&#x27;s totally feasible if you wrote it?<p>It seems you&#x27;re just ranting against bad programmers instead of missing language features then.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 17:28:33 &#43;0000 UTC">2021-08-18 17:28:33 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I believe you&#x27;re being disingenuous.<p>I&#x27;m rambling because our programming languages make it awkward, difficult, and performance-sub-optimal to do such things.<p>If you do what I often do, you have to wrap and unwrap your primitives explicitly so that you can use APIs that others have written.<p>You take a performance hit with all of the boxing and unboxing.<p>It&#x27;s absolutely still a missing language feature if the language doesn&#x27;t have ergonomic &quot;newtypes&quot;. Just because it&#x27;s possible to write a ton of poorly performing boilerplate to accomplish my goal of type safety, doesn&#x27;t mean that I think we&#x27;re done. You can do these things with essential zero runtime overhead and almost no boilerplate and friction in the code. It&#x27;s entirely possible to do newtypes and refinement types in Rust, Haskell, D, Scala, even TypeScript. It&#x27;s just that most of those languages are not very popular. TypeScript is the most mainstream of the lot.<p>I think &quot;good programmers&quot; are more of the problem than bad programmers. Good programmers are so used to these shit languages and all of their workarounds (excuse me: &quot;design patterns&quot;) that they can&#x27;t even see the forest for the trees and realize how tedious and stupid most of our work actually is. There&#x27;s no Earthly reason it should take a million lines of code to write a CRUD app (I&#x27;m counting dependencies).
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=hnfong" target="_blank">hnfong</a>   <span class="timeago" data-date="2021-08-18 18:38:09 &#43;0000 UTC">2021-08-18 18:38:09 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I sympathize if you put it this way. The boxing and unboxing of types can probably be done better in some languages. I suspect a well-optimized C++ compiler can probably make the perf cost mostly free if you give it the class the correct magic keywords.<p>It&#x27;s just that you seem make a bigger fuss out of the problem than it actually is. Even with Java, there&#x27;s boilerplate and some performance cost, but it&#x27;s doable, and the real reason people don&#x27;t do it (when they should) is because they underestimate the risk of making mistakes. (eg. Nobody uses JSON if the requirement is to squeeze out every single ounce of performance from the CPU, there are better binary protocols.)<p>Maybe it&#x27;s indeed Stockholm syndrome, but I don&#x27;t really see it as a problem of the &quot;world at large&quot;. The tech is there, it&#x27;s easily and freely available. Of course there&#x27;s trade off between popularity and technical superiority, as always, but there&#x27;s really nothing preventing you from writing Rust or TypeScript right now, if you feel strongly enough about it. So your job requires you to use a 3 decade old language? You can always change jobs or start your own thing using new tech. I mean, I&#x27;m using these 3-decades-old languages at work but at least I know it&#x27;s a choice I make in exchange for decent pay and a stable job. Complaining about the lack of adoption of new tech (or coworkers not utilizing the type checking system properly) and then not taking proactive steps to fix the problem seems a tad bit hypocritical to me... The reason the world has not caught on with better tech is precisely due to the same reasons that you&#x27;re not using it in the first place.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=hnfong" target="_blank">hnfong</a>   <span class="timeago" data-date="2021-08-18 15:34:56 &#43;0000 UTC">2021-08-18 15:34:56 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            #1 You want to define a type with specific properties.<p>#2 You don&#x27;t want to write a validator.<p>#3 Presumably you want to instantiate values of that type with user given input.<p>I don&#x27;t think the three requirements make sense at all.<p>If you&#x27;re willing to drop #3 you can always use some sort of enum-ish thing.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 16:17:05 &#43;0000 UTC">2021-08-18 16:17:05 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I don&#x27;t want to write a validator and litter calls to it throughout my code base.<p>I want the &quot;validator&quot; to be the constructor of a type (or a refinement mechanism, etc).<p>Then every function in my code base can have a clear contract via its type signature. What good is a function that says it accepts a string and returns a string if it actually just explodes when given some strings? That&#x27;s not the same thing as returning a string...<p>I want to do three-ish things:<p>1. Make my function&#x27;s type signature be correct. It is NOT correct to say that you accept an &quot;int&quot; but actually crash if you&#x27;re given `0`.<p>2. Push bug catching to compile time instead of runtime. Calling a validation function inside a function is a runtime check. In the meantime I can write 100 calls to a function that I know will cause a crash and the compiler will say nothing.<p>3. Push type requirements to the callers of functions. Everyone preaches &quot;validate at the edges&quot;, but if your function signatures had very precise types, that would happen &quot;automatically.&quot; Your code won&#x27;t compile unless you pipe the correct types all the way from the top function call down to the bottom one.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=tuatoru" target="_blank">tuatoru</a>   <span class="timeago" data-date="2021-08-17 23:44:13 &#43;0000 UTC">2021-08-17 23:44:13 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt;  Why not a type for even numbers? Odd, prime, not-prime, etc?<p>Those are not mathematical entities in the same way as are the sets W (whole numbers) or N (natural numbers, indices).  It is reasonable to specify your domain closely, otherwise you end up with sqlite.<p>&quot;Why not a type for datetimes or complex numbers?&quot; would be a better question, as those are different kinds of things but not quite so frequently used in programming.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=wmanley" target="_blank">wmanley</a>   <span class="timeago" data-date="2021-08-19 12:29:02 &#43;0000 UTC">2021-08-19 12:29:02 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt;  It is reasonable to specify your domain closely, otherwise you end up with sqlite<p>It seems like you&#x27;re trying to use SQLite as an example of something you don&#x27;t want to end up with.  This seems backwards so it weakens your argument.  SQLite is one of the most widely deployed, reliable, broadly applicable and all round useful pieces of software ever written.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-17 23:54:34 &#43;0000 UTC">2021-08-17 23:54:34 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            This is a bit of a false distinction, to me.  Especially as a string, the motivating example for this thread, is also not the same.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 23:52:16 &#43;0000 UTC">2021-08-17 23:52:16 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I would question that primes are not mathematical entities.<p>Same for other sets like &quot;not-primes&quot;, or the odd numbers.<p>Sets can be nicely approximated with types. (Some people say even that types correspond directly to sets).
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=karmakaze" target="_blank">karmakaze</a>   <span class="timeago" data-date="2021-08-18 01:41:43 &#43;0000 UTC">2021-08-18 01:41:43 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            OT: It&#x27;s funny how primes are given this property of &#x27;primeness&#x27; and not-primes are those that don&#x27;t have the property, when it&#x27;s actually the opposite. The not-primes have the property of being composite (a product) and the primes are the negative space of numbers excluding composite numbers.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-18 14:03:56 &#43;0000 UTC">2021-08-18 14:03:56 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I was more pointing in the direction of &quot;sets&quot; in general.<p>Sets as such are mathematical entities. (Isn&#x27;t there even a category of sets where sets are objects)?<p>But apparently not everybody agree as this got down votes; or someone don&#x27;t see the parallels between sets and types? Strange.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=initplus" target="_blank">initplus</a>   <span class="timeago" data-date="2021-08-17 20:59:31 &#43;0000 UTC">2021-08-17 20:59:31 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Validating an email is different from validating a primitive.<p>You can validate a primitive like an int based on it&#x27;s own state alone.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=taeric" target="_blank">taeric</a>   <span class="timeago" data-date="2021-08-17 21:20:38 &#43;0000 UTC">2021-08-17 21:20:38 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Different validation, but yes?<p>And then there is validating it is a valid int, but is it valid to use it somewhere?  7642468 is a valid int, but is it a valid address?<p>That is, the primitives are unlikely to be your concern in programming.  Handy tools, but not your problem domain.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=mr_toad" target="_blank">mr_toad</a>   <span class="timeago" data-date="2021-08-18 01:53:35 &#43;0000 UTC">2021-08-18 01:53:35 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; You really are asking for a type that is &quot;valid data.&quot;<p>Enumerations come to mind.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=mtreis86" target="_blank">mtreis86</a>   <span class="timeago" data-date="2021-08-17 22:42:10 &#43;0000 UTC">2021-08-17 22:42:10 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Common Lisp can do that<p><pre><code>  CL-USER&gt; (defun non-empty-string-p (string)
             (and (stringp string)
                  (plusp (length string))))
  NON-EMPTY-STRING-P

  CL-USER&gt; (deftype non-empty-string ()
             `(satisfies non-empty-string-p))
  NON-EMPTY-STRING

  CL-USER&gt; (typep &quot;&quot; &#x27;non-empty-string)
  NIL

  CL-USER&gt; (typep &quot; &quot; &#x27;non-empty-string)
  T</code></pre>
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=scns" target="_blank">scns</a>   <span class="timeago" data-date="2021-08-18 05:31:41 &#43;0000 UTC">2021-08-18 05:31:41 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Mumble, Greenspun, smthing somethng
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=raspasov" target="_blank">raspasov</a>   <span class="timeago" data-date="2021-08-17 16:05:24 &#43;0000 UTC">2021-08-17 16:05:24 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Checkout Clojure spec for a very expressive way of defining data requirements. It allows you to use arbitrary functions to describe data requirements. That way you are not limited by static, compile-time only descriptions of data flowing through your program.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-17 19:02:01 &#43;0000 UTC">2021-08-17 19:02:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I used Clojure on a project while spec was still alpha&#x2F;beta or something, so I never used it. It does sound interesting, but I&#x27;m skeptical. Even the way you described it- I&#x27;m still just writing a function to validate my data, aren&#x27;t I? Is that truly any different than just calling `validateFoo()` at the top of my functions in any other language?
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=eckesicle" target="_blank">eckesicle</a>   <span class="timeago" data-date="2021-08-17 20:27:05 &#43;0000 UTC">2021-08-17 20:27:05 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &#x27;Maybe Not&#x27; is a great talk on this subject matter.
<a href="https:&#x2F;&#x2F;m.youtube" rel="nofollow">https:&#x2F;&#x2F;m.youtube</a>
.com&#x2F;watch?v=YR5WdGrpoug
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=scns" target="_blank">scns</a>   <span class="timeago" data-date="2021-08-18 05:48:17 &#43;0000 UTC">2021-08-18 05:48:17 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=YR5WdGrpoug" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=YR5WdGrpoug</a>
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=raspasov" target="_blank">raspasov</a>   <span class="timeago" data-date="2021-08-17 22:04:10 &#43;0000 UTC">2021-08-17 22:04:10 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            There&#x27;s more power than that in spec. For example, you can globally define :address&#x2F;zip to be a string that&#x27;s more than, say, N characters long. Now anytime you encounter an :address&#x2F;zip, regardless of whether it is inside, say :billing-address or :shipping-address dictionary&#x2F;map, it can be checked for those function predicates.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=WalterBright" target="_blank">WalterBright</a>   <span class="timeago" data-date="2021-08-17 20:58:31 &#43;0000 UTC">2021-08-17 20:58:31 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; almost zero mainstream (statically typed) programming languages can even let you write down that you want a non-empty string.<p>Today D will fulfill your dreams!<p><pre><code>    struct MyString {
        private string s = &quot;error&quot;;
        alias s this;

        this(string s) {
            assert(s.length);
            this.s = s;
        }
    }


    void main() {
        MyString ms = &quot;hello&quot;;
        test(ms);
        MyString mserror = &quot;&quot;; &#x2F;&#x2F; runtime assert fail
    }

    void test(string s) { }</code></pre>
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Leherenn" target="_blank">Leherenn</a>   <span class="timeago" data-date="2021-08-17 21:12:58 &#43;0000 UTC">2021-08-17 21:12:58 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Would it be possible to have a static assert? In that case I would expect it to fail at compile time, not run time.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=mhh__" target="_blank">mhh__</a>   <span class="timeago" data-date="2021-08-18 04:16:47 &#43;0000 UTC">2021-08-18 04:16:47 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            No.<p>If D had unlimited access to C code at CTFE then maybe you could implement refinement types at compile time as a library but for now you are stuck with what Walter has posted. I implemented a sketch of the API for this ages ago but the actual type checking had to be done at module load time because was of aforementioned (justified) restrictions to CTFE<p><i>Dependant</i> types are a whole other monster.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=WalterBright" target="_blank">WalterBright</a>   <span class="timeago" data-date="2021-08-17 21:17:17 &#43;0000 UTC">2021-08-17 21:17:17 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            You can use static asserts if you turn the constructor into a template and pass the initializer into a compile time parameter.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 00:51:47 &#43;0000 UTC">2021-08-18 00:51:47 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I love that! So it&#x27;s the `alias s this` that&#x27;s the magic here, I assume? It&#x27;s making the `this` pointer actually point to the stored field? That&#x27;s awesome!
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 22:15:03 &#43;0000 UTC">2021-08-17 22:15:03 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            You&#x27;re looking for refinement-types?<p>Scala to the rescue:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;fthomas&#x2F;refined" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;fthomas&#x2F;refined</a><p>And a new one:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Iltotore&#x2F;iron&#x2F;" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;Iltotore&#x2F;iron&#x2F;</a><p>The latter will be zero overhead once a compiler ticket is closed.<p>Both solutions will yield compile time checks where possible, and fall back to runtime checks when the data isn&#x27;t statically known.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 23:48:17 &#43;0000 UTC">2021-08-17 23:48:17 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Related to refinement-types is the concept of &quot;parsing, not validating&quot;:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21476261" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21476261</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27166162" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27166162</a>
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 00:50:32 &#43;0000 UTC">2021-08-18 00:50:32 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Yeah, pretty much. I know such things exist on the periphery, but I think it&#x27;s extremely disappointing that we keep churning out &quot;new&quot; languages that are basically &quot;Here&#x27;s C again, but with one interesting feature from the 70s!&quot;<p>I worked on a Scala once several years ago and I really didn&#x27;t &quot;get it&quot;. The more I use Kotlin, the more I wish it were Scala.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=amelius" target="_blank">amelius</a>   <span class="timeago" data-date="2021-08-17 21:11:08 &#43;0000 UTC">2021-08-17 21:11:08 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; the vast majority of the time, I&#x27;m just disappointed in how bad our programming tools (including languages) are<p>If you are disappointed in programming tools, you didn&#x27;t see hardware design tools yet.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=kwertyoowiyop" target="_blank">kwertyoowiyop</a>   <span class="timeago" data-date="2021-08-17 20:37:22 &#43;0000 UTC">2021-08-17 20:37:22 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It’d also be handy to put other limits on my numeric variables, for instance to automatically throw an exception if an angle delta goes out of the range -180 to 180, or whatever.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=Jtsummers" target="_blank">Jtsummers</a>   <span class="timeago" data-date="2021-08-17 21:22:33 &#43;0000 UTC">2021-08-17 21:22:33 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Yes, it is handy. This is why I like Ada (or the idea of it, it&#x27;s rarely been used in my work because it&#x27;s hard to sell others on) for safety critical systems. With SPARK&#x2F;Ada you can even work towards proofs that your code won&#x27;t assign outside of that range so that you don&#x27;t end up with runtime exceptions.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ComodoHacker" target="_blank">ComodoHacker</a>   <span class="timeago" data-date="2021-08-17 16:38:13 &#43;0000 UTC">2021-08-17 16:38:13 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt;how often have you ever written a function that requested a string as input and actually wanted an empty string?<p>To be fair, I do it quite often. Most of the strings I deal with in my code are coming from user input, and most of them are optional. They are usually just passed to&#x2F;from a database. If the string has some internal meaning (like ULSs or file paths), it usually gets wrapped in an object anyway.<p>If you&#x27;re processing some formal language or network protocol, that&#x27;s another story.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-17 19:09:14 &#43;0000 UTC">2021-08-17 19:09:14 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Let me ask you this, though. If your strings that come from user inputs are optional, doesn&#x27;t that mean they could also just not be present (as in null)? Why do you need or want two different ways to express &quot;nothing&quot;? Are all of the text fields just funneled right into the database without checking&#x2F;validating any of them? I&#x27;ve written a number of RESTy&#x2F;CRUDy APIs and I can&#x27;t count the number of &quot;check that username isn&#x27;t empty&quot; checks I&#x27;ve written over the years.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=feoren" target="_blank">feoren</a>   <span class="timeago" data-date="2021-08-17 20:49:01 &#43;0000 UTC">2021-08-17 20:49:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The argument for disallowing nulls is much stronger than the argument for demanding a compiler-enforced non-empty string. I definitely support the ability to declare variables, including strings, as non-nullable. An empty string is simply analogous to the number 0. It doesn&#x27;t really overlap in meaning with null. It&#x27;s true it would be useful to occasionally disallow the number 0, but only very occasionally. The obvious example is division, but having a representation of +&#x2F;- infinity alleviates some cases.<p>&gt; I&#x27;ve written a number of RESTy&#x2F;CRUDy APIs and I can&#x27;t count the number of &quot;check that username isn&#x27;t empty&quot; checks I&#x27;ve written over the years.<p>Paraphrasing: &quot;I&#x27;ve written the same kind of method over and over throughout my career and have been unable to (or made no attempt to) abstract it away.&quot; I love strong type systems, but it doesn&#x27;t sound like the type system is your problem here. The problem is that you&#x27;re constantly re-implementing the same business logic.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 01:26:02 &#43;0000 UTC">2021-08-18 01:26:02 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; The argument for disallowing nulls is much stronger than the argument for demanding a compiler-enforced non-empty string. I definitely support the ability to declare variables, including strings, as non-nullable. An empty string is simply analogous to the number 0. It doesn&#x27;t really overlap in meaning with null. It&#x27;s true it would be useful to occasionally disallow the number 0, but only very occasionally. The obvious example is division, but having a representation of +&#x2F;- infinity alleviates some cases.<p>Well, of course you should be able to declare something non-null. What do I look like, someone who likes Java? :p My point wasn&#x27;t that I WANT to use null instead of an empty collection&#x2F;string, it was that our languages give us multiple mechanisms by which we can pass in &quot;nothing&quot; for strings&#x2F;collections, but they give us zero ways to ask for a non-empty string&#x2F;collection. That&#x27;s super frustrating! Yes, of course &quot;null&quot; and &quot;empty set&quot; are technically and semantically different. But they&#x27;re close enough that you could actually deal with having only non-empty strings + nulls and be able to mostly express what you want. That&#x27;s not the case if I actually want a non-empty string in many of today&#x27;s languages. Not if I want it to be usable with other APIs and the standard libraries, that is.<p>&gt; Paraphrasing: &quot;I&#x27;ve written the same kind of method over and over throughout my career and have been unable to (or made no attempt to) abstract it away.&quot; I love strong type systems, but it doesn&#x27;t sound like the type system is your problem here. The problem is that you&#x27;re constantly re-implementing the same business logic.<p>Eh, no. I haven&#x27;t worked in the same language or on the same project for my whole career. So, yeah, I&#x27;ve noticed that I&#x27;m pretty much always either defining a bunch of boilerplate types up front or I regret not doing it when a 0 hits the database because someone wasn&#x27;t careful with their math or had an off-by-one error.<p>Maybe I should publish a book a la Gang of Four and call it &quot;Static Type Patterns&quot;. ;)<p>So, yeah. Believe it or not, I HAVE implemented stuff like PositiveInt and NonEmptyString a bunch of times in a bunch of languages. And it&#x27;s better than not having it, but it still sucks because in several of those languages, it means that I have all kinds of noise converting to and from, e.g., the native string type. And that&#x27;s because most of the above languages have no concept of &quot;newtypes&quot; and have no intention of letting programmers define or refine &quot;primitives&quot;.<p>It&#x27;s not really about &quot;business logic&quot;. It&#x27;s about &quot;I know how to describe the shape of this data, but my statically typed language won&#x27;t let me.&quot;
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 22:34:52 &#43;0000 UTC">2021-08-17 22:34:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; I&#x27;ve written a number of RESTy&#x2F;CRUDy APIs and I can&#x27;t count the number of &quot;check that username isn&#x27;t empty&quot; checks I&#x27;ve written over the years.<p>But you do it only once, thereafter you have hopefully some &quot;Username&quot; type of object which is guarantied to contain a valid username.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 01:45:04 &#43;0000 UTC">2021-08-18 01:45:04 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Correct.<p>But, the reason I&#x27;m bitching about it is because, in most languages, you then cannot use your Username type in place of a &quot;native&quot; string, where some third-party or standard library function just expects a string. So now you have to convert back and forth.<p>And if this is a language like pre-record Java, fucking forget it. Define the class, implement equals(), implement hashCode(), write a getter for the wrapped string so that you can pass its guts to functions that expect strings, write the constructor. Speaking of the constructor, do you let the constructor throw an exception? Do you make the constructor private and write a factory function? Does that factory throw an exception or return a failure value? Checked exception or unchecked exception?<p>Now do that everywhere that you want a &quot;newtype&quot;.<p>Is it possible? Absolutely. I&#x27;ve done it. Is the amount of effort for such a simple concept reasonable? No.<p>And my other point is that I actually want a non-empty string MUCH more often than I want a potentially-empty string.<p>I think that programmers are especially prone to just internalizing bullshit and papercuts. We like &quot;solving puzzles&quot; and we&#x27;re pretty smart and adaptable. So when we encounter something that&#x27;s actually kind of insane, but we eventually figure out a workaround, we completely forget that it was ever insane in the first place (see: Gang of Four patterns).
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=scns" target="_blank">scns</a>   <span class="timeago" data-date="2021-08-18 06:03:12 &#43;0000 UTC">2021-08-18 06:03:12 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Have you worked with Kotlin yet? Since 1.5 Result&lt;T&gt; is a valid return type. Inline classes are thin wrappers and compiled out. Data classes automatically give you a toString method. With sealed classes you can implement ADTs.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-19 13:49:20 &#43;0000 UTC">2021-08-19 13:49:20 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I have. I generally like Kotlin, but even that makes it a little too cumbersome to work with &quot;newtypes&quot; such as a NonEmptyString type. Here&#x27;s what I do for a NotBlankString in Kotlin 1.5+:<p>@JvmInline
value class NotBlankString private constructor(private val value: String) : CharSequence {<p><pre><code>    override val length: Int
        get() = value.length

    override fun get(index: Int): Char = value[index]

    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = value.subSequence(startIndex, endIndex)

    override fun toString(): String = value

    companion object {
        fun of(value: CharSequence): NotBlankString? = if (value.isBlank()) null else NotBlankString(value.toString())
    }</code></pre>
}<p>The problem is that most APIs in Kotlin and Java (including the standard library as well as almost all third party libraries) work specifically with String, which is a final class. So, using my NotBlankString is a pain in the ass because I have to explicitly call toString() for most APIs.<p>Also, I do implement CharSequence, because String does. But CharSequence is a terrible interface and we should probably just pretend it doesn&#x27;t exist. I somewhat regret even acknowledging its presence.<p>One of the limitations of value classes is that they cannot implement an interface by delegation, either. So I have to implement CharSequence by hand, instead of writing `: CharSequence by value`.<p>If you define a &quot;newtype&quot; in Kotlin by using a value class, don&#x27;t forget to override toString to call value.toString(). By default, it&#x27;s going to print like a data class format: &quot;NotBlankString(value=foo)&quot;<p>But, overall, this is a much better than the situation in many languages. But it&#x27;s still just awkward enough that I think a lot of people don&#x27;t bother.<p>In my opinion, a statically typed language should HIGHLY prioritize the ergonomics of defining and using custom defined types. Ideally, I would be able to declare somehow that NotBlankString can do everything a String can do, and therefore be able to pass my NotBlankString type into any function that asks for a String. It would also be better for ergonomics if I could define my own type refinement, instead of needing to call a constructor- kind of like how Kotlin does &quot;smart casting&quot; with null and sealed types:<p><pre><code>    val s: String = getSomeString()
    if (s is NotBlankString) {
        doStuff(s) &#x2F;&#x2F; takes a NotBlankString
    } else {
        doOtherStuff()
    }</code></pre>
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=onemoresoop" target="_blank">onemoresoop</a>   <span class="timeago" data-date="2021-08-17 20:53:53 &#43;0000 UTC">2021-08-17 20:53:53 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I hear your dismay but you could easily build your own library of string validations which can extend however you want and can reuse it as much as you need.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=lamontcg" target="_blank">lamontcg</a>   <span class="timeago" data-date="2021-08-17 22:18:18 &#43;0000 UTC">2021-08-17 22:18:18 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; How many times did you write &quot;int&quot; when you actually only wanted a positive number?<p>subtracting one from zero and getting max_uint can be its own brand of fucking horribly awful.<p>having the language itself throw in that circumstance can also be exactly what you don&#x27;t want.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Jtsummers" target="_blank">Jtsummers</a>   <span class="timeago" data-date="2021-08-17 22:22:14 &#43;0000 UTC">2021-08-17 22:22:14 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            In some languages you can get a choice. Broken record time, but Ada:<p><pre><code>  type Byte is unsigned 2**3;
</code></pre>
This will permit any value in the range [0,7] and when you exceed it (in either direction) it will wrap around (the desired action if you choose this type). In contrast:<p><pre><code>  type Byte is range 0..7;
</code></pre>
Will give you a runtime error when you exceed the bounds by trying to increase beyond 7 or decrease below 0. Having this choice is nice, you get to decide the semantics for your system.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=lamontcg" target="_blank">lamontcg</a>   <span class="timeago" data-date="2021-08-17 22:28:00 &#43;0000 UTC">2021-08-17 22:28:00 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Yeah I took Ada for CS 210&#x2F;211 back in 1991, are we there yet?
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Jtsummers" target="_blank">Jtsummers</a>   <span class="timeago" data-date="2021-08-17 22:39:02 &#43;0000 UTC">2021-08-17 22:39:02 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Ada&#x27;s good, but it will never win. The open source compilers are solid, but no one wants to learn it. It&#x27;s (depending on who you ask): Too old, too verbose, BDSM programming, not Rust, not Haskell, not C.<p>It has a lot of positive features going for it, but it <i>is</i> verbose. That verbosity is a major distraction for people who can&#x27;t handle it, they want their very short keywords or, better, no keywords just symbols. Curly braces are somehow better than begin&#x2F;end even though begin&#x2F;end really aren&#x27;t hard to type. Ada shines, particularly, in the long tail of system maintenance, not in the writing (arguable: the type system certainly helps a lot in the writing, the syntax doesn&#x27;t). So I press for it where it belongs, and don&#x27;t where it doesn&#x27;t. But when someone laments the state of type systems, I point it out.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 23:00:08 &#43;0000 UTC">2021-08-17 23:00:08 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Give it a new syntax, and try again…<p>It&#x27;s not so difficult nowadays to write a &quot;syntax-transpiler&quot;. The hard part, the language, would remain the same.<p>People seem having done so successfully with OCaml, see ReScript.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Jtsummers" target="_blank">Jtsummers</a>   <span class="timeago" data-date="2021-08-17 23:17:26 &#43;0000 UTC">2021-08-17 23:17:26 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The verbosity can only be removed at a superficial level. Many people object to begin and end, but they’d chafe even more if they got further. For good reasons (Ada leans toward explicit declarations in favor of implicit ones) you have to list each sub program you depend on in a module by name. Even if you don’t import it’s symbols. And you have to explicitly instantiate generics (like C++ templates) rather than the compiler inferring your intention. Things like that cannot be removed from the language so only a superficial improvement can be achieved, for what benefit?
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 23:39:58 &#43;0000 UTC">2021-08-17 23:39:58 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It&#x27;s difficult to design whole languages (you won&#x27;t get anywhere close some adoption in production at important places under ten years I guess; if you&#x27;re lucky of course). Having already something that proved its merit and strong foundations is for sure a good starter for a &quot;new language&quot; (as it would streamline the process to create such &quot;new&quot; language drastically).<p>People are carving for powerful, safe, fast languages. So there is a market.<p>If it&#x27;s &quot;only&quot; about the verbosity and some cumbersome edges this could be fixed with some &quot;overlay syntax&quot;.<p>To be honest I&#x27;m one of those people that looked a few times at Ada as it was said to be powerful, fast, and safe. But it looks so awkward in my eyes; even I know I should not judge languages by syntax! The look-and-feel is just a strong point. I guess it&#x27;s not only me…<p>So I suspect a syntactic make-over could give new life to an old but powerful language. Just by making it look more &quot;modern&quot; (whatever this means).
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 22:27:54 &#43;0000 UTC">2021-08-17 22:27:54 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Are that static or runtime checks (or both)?
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=Jtsummers" target="_blank">Jtsummers</a>   <span class="timeago" data-date="2021-08-17 22:36:07 &#43;0000 UTC">2021-08-17 22:36:07 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Definitely runtime, potential for compile time. The compile time checks will at least prevent obvious cases (assigning a value out of the range like using either Byte type above: <i>T := -1</i> will get a compile time error). Using the second Byte type, paired with SPARK&#x2F;Ada, this bit of code should set off the proof system and prevent compilation:<p><pre><code>  procedure Foo is
    type Byte is range 0..7;
    T : Byte := 0;
  begin
    T := Byte - 1;
  end Foo;
</code></pre>
(Not that that&#x27;s useful code, but a basic example.) That shouldn&#x27;t make it past the SPARK&#x2F;Ada system to compilation. Now change it to this:<p><pre><code>  function Foo(T : Byte) return Byte is
  begin
    return T + 1;
  end Foo;
</code></pre>
and SPARK&#x2F;Ada should warn (been a bit, but should also fail to compile) that this could cause overflow.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 02:05:15 &#43;0000 UTC">2021-08-18 02:05:15 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; subtracting one from zero and getting max_uint can be its own brand of fucking horribly awful.<p>Agreed. Silent wrap-around on overflow is also a really terrible idea.<p>&gt; having the language itself throw in that circumstance can also be exactly what you don&#x27;t want.<p>Then you have to check before you do it. Or call a special overflowing function. The default should absolutely be a crash. That wouldn&#x27;t even really be anything new: what happens when you divide by zero in most languages? Index an array with an index &gt; length? Should the array index just wrap around and give you the element at length % index?
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=klyrs" target="_blank">klyrs</a>   <span class="timeago" data-date="2021-08-17 23:54:14 &#43;0000 UTC">2021-08-17 23:54:14 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Nah, unsigned ints are magical.  Why check<p><pre><code>   (i &lt; 0) || (i &gt; n)
</code></pre>
when you can just simplify it to<p><pre><code>   (i &gt; n)
</code></pre>
after verifying that n &lt; max_uint?
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=mbrodersen" target="_blank">mbrodersen</a>   <span class="timeago" data-date="2021-08-19 03:29:09 &#43;0000 UTC">2021-08-19 03:29:09 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Refinement Types is the answer. See Liquid Haskell, F*, Dafny etc.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=" target="_blank"></a>   <span class="timeago" data-date="2021-08-17 22:39:03 &#43;0000 UTC">2021-08-17 22:39:03 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=sharikous" target="_blank">sharikous</a>   <span class="timeago" data-date="2021-08-17 21:30:43 &#43;0000 UTC">2021-08-17 21:30:43 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Have you tried Ada? Its type system is the closest I could think of to your use case?
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 01:49:52 &#43;0000 UTC">2021-08-18 01:49:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I haven&#x27;t, but I&#x27;ve done a fair amount of reading about it and that is the kind of thing I&#x27;m talking about.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ElFitz" target="_blank">ElFitz</a>   <span class="timeago" data-date="2021-08-17 23:12:18 &#43;0000 UTC">2021-08-17 23:12:18 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Perhaps via some monad, like Swift optionals?<p>Unless it isn’t a monad and I still haven’t understood those?
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=hota_mazi" target="_blank">hota_mazi</a>   <span class="timeago" data-date="2021-08-17 17:07:35 &#43;0000 UTC">2021-08-17 17:07:35 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Mmmh... these are not very convincing examples.<p>Statically typed languages give you u8&#x2F;i8 types of numbers.<p>Maybe having a non empty string, or non empty list, type is useful now and then, but in practice, just have your code work just as well on both empty and non empty values, and you&#x27;re good to go.<p>I&#x27;m pretty happy with the languages we have today overall (Kotlin and Rust at the top, but C#, Swift, and Java get an honorable mention).
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-17 18:59:26 &#43;0000 UTC">2021-08-17 18:59:26 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Your comment kind of galvanizes my view that most of us suffer from Stockholm Syndrome with respect to our programming languages.<p>As another commenter said, <i>some</i> statically typed languages give you unsigned numbers. Maybe most of them do. But definitely not some of the most popular ones. And out of the ones that do, they are often really unhelpful.<p>C&#x27;s unsigned numbers and implicit conversions are full of foot-guns.<p>Java basically doesn&#x27;t have unsigned ints. It does kind of have this weird unsigned arithmetic API over signed ints, but it&#x27;s really awkward and still bug-prone to use.<p>Kotlin&#x27;s unsigned numbers API is very poor. Very. Kotlin does not give a crap if I write: `Int.MIN_VALUE.toUInt()`, so it&#x27;s perfectly happy to just pretend a negative number <i>is</i> an unsigned number. Not to mention that unsigned number types are implemented as inline&#x2F;value classes which don&#x27;t even actually work correctly in the current version of the language (just go look at the bug tracker- I literally can&#x27;t use value classes in my project because I&#x27;ve encountered multiple DIFFERENT runtime crash bugs since 1.5 was released). It, like Java and C, etc, is perfectly happy to wrap around on arithmetic overflow, which means that if you didn&#x27;t guess your types correctly, you&#x27;re going to end up with invalid data in your database or whatever.<p>Rust and Swift have good unsigned number APIs.<p>Notice also that I didn&#x27;t say anything about non-empty collections. Yes, I absolutely want non-empty collection types, but that is no where NEAR as important and useful as non-empty strings, even though they might seem conceptually similar. I&#x27;m willing to assert, like the bold internet-man I am, that you and all of the rest of us almost NEVER actually want an empty string for anything. I never want to store a user with an empty name, I never want to write a file with an empty file name, I never want to try to connect to a URL made from an empty host name, etc, etc, etc. It is very often perfectly acceptable to have empty collections, though. It&#x27;s also very frequent that you DO want a non-empty collection, which is why we should have both.<p>We don&#x27;t even need empty strings (or collections, really) if we have null.<p>You say you like Kotlin and Rust and I work with both of them extensively. I can point out a great many shortcomings of Kotlin in particular. I used to be enamored with it, but the more I use it, the more shortcomings, edge cases, bugs, and limitations I run into. Rust is pretty great, but even that has some real issues- especially around how leaky the trait abstraction is. But at least Rust&#x27;s excuse is that it&#x27;s a low-level-ish systems language. It&#x27;s these &quot;app languages&quot; that irritate me the most.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=isotropy" target="_blank">isotropy</a>   <span class="timeago" data-date="2021-08-17 20:30:40 &#43;0000 UTC">2021-08-17 20:30:40 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; We don&#x27;t even need empty strings (or collections, really) if we have null.<p>This feels exactly backwards to me:  I almost always want my sequence-like types to have a well-defined zero-length element, and I almost never want to allow a NULL value for a variable.  NULL is so much worse than [] or &#x27;&#x27;.  Think about concat().  When the trivial members of a type support most of the same behaviors as the nontrivial ones, that makes error checking so much easier.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 01:57:08 &#43;0000 UTC">2021-08-18 01:57:08 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Of course you&#x27;re right! That statement was intended to be hyperbolic. I&#x27;m not actually suggesting that it would be a good idea to NOT have zero-sized collections.<p>I&#x27;m just exasperated that most of these modern, statically typed languages, give us TWO ways to write &quot;nothing&quot; (null and empty) and ZERO ways to write &quot;must have something&quot;.<p>You COULD, theoretically, write a concat() that takes multiple, nullable, non-empty strings and returns a nullable non-empty string. Of course that&#x27;s not ideal and would be horribly unergonomic. But you COULD do it. But how do you write a concat() that statically guarantees that if any of its arguments are non-empty that its output will be non-empty? You pretty much don&#x27;t.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=hota_mazi" target="_blank">hota_mazi</a>   <span class="timeago" data-date="2021-08-18 04:59:43 &#43;0000 UTC">2021-08-18 04:59:43 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            There is nothing wrong with null if your language supports nullability in its type system.<p>In such languages (e.g. Kotlin), null is perfectly safe to use whenever you need to represent an absent value.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=specialist" target="_blank">specialist</a>   <span class="timeago" data-date="2021-08-18 04:58:23 &#43;0000 UTC">2021-08-18 04:58:23 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; <i>...shortcomings of Kotlin...</i><p>I&#x27;d read that newsletter.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ragnese" target="_blank">ragnese</a>   <span class="timeago" data-date="2021-08-18 16:56:27 &#43;0000 UTC">2021-08-18 16:56:27 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Don&#x27;t get me wrong, I mostly like working Kotlin. But the more I do, the more I realize what a hodgepodge of features it really is. A bunch of features don&#x27;t really work together that well. And a bunch of features are only 80% (or less) of what I actually want.<p>For example, what if I don&#x27;t like data class&#x27;s stupid copy() method? How do I opt out? You can&#x27;t.<p>Value classes can&#x27;t be used as varargs, can&#x27;t implement an interface by delegating to the wrapped value. (Forgetting the fact that they&#x27;re just buggy as all hell and I keep getting runtime crashes from them being overly aggressively optimized away)<p>And it, of course, inherits a ton of badness from Java. Like the crappy type-erased generics, lack of type classes, etc. It chose to just use Java&#x27;s standard collection types and encourage copies instead of using persistent collections by default. It hides the mutability under &quot;read only&quot; interfaces, but that&#x27;s not at all concurrency-safe. Map is not a Collection or an Iterable, which is dumb. Map&lt;K, V&gt;&#x27;s type parameters are also allowed to be nullable types, which means that Map.getOrElse{} is actually wrong in the standard library.<p>Since Kotlin chose nullable types instead of Option&lt;T&gt;, you can&#x27;t express &quot;nested&quot; emptiness. This means that the Map API is janky if you need to store nullable types. Map.get returns null if there was no value stored, but what if the value stored IS null? Then you have to call Map.contains(key), which means you have to hash the key twice to reliably pull out values.<p>There&#x27;s just a lot of papercuts.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=AnimalMuppet" target="_blank">AnimalMuppet</a>   <span class="timeago" data-date="2021-08-17 18:00:01 &#43;0000 UTC">2021-08-17 18:00:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            <i>Some</i> statically typed languages give you u8&#x2F;i8.  Java doesn&#x27;t, despite it being one of your &quot;honorable mention&quot; languages.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=amelius" target="_blank">amelius</a>   <span class="timeago" data-date="2021-08-17 21:20:59 &#43;0000 UTC">2021-08-17 21:20:59 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Another problem is that no language hits the sweetspot of a truly general purpose language. For example Rust doesn&#x27;t allow freestyle functional programming (Haskell relies on a garbage collector for a reason), whereas at the other end of the spectrum Haskell doesn&#x27;t allow precise control of CPU usage.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=pharmakom" target="_blank">pharmakom</a>   <span class="timeago" data-date="2021-08-17 22:55:27 &#43;0000 UTC">2021-08-17 22:55:27 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Is such a language even possible? Seems like you have identified two desirable traits that conflict with each other.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=amelius" target="_blank">amelius</a>   <span class="timeago" data-date="2021-08-18 22:15:12 &#43;0000 UTC">2021-08-18 22:15:12 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            You could have a language that offers both in different parts of the program. Just like Rust has an &quot;unsafe&quot; keyword, you could have a &quot;garbage_collected&quot; keyword or a &quot;functional&quot; keyword.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=scythe" target="_blank">scythe</a>   <span class="timeago" data-date="2021-08-17 15:47:09 &#43;0000 UTC">2021-08-17 15:47:09 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt;GC can be largely pauseless for many practical purposes and a GC language can be within 2x-3x the performance of C-like languages.<p>To that end, it seems like only recently we&#x27;ve seen automatic reference counting [Obj-C, Rust, Swift] and&#x2F;or compile-time garbage collection [Mercury] in a non-toy implementation. &quot;Breakthrough&quot; is a difficult word because it refers to discovery <i>and</i> impact, with the latter coming long after the former, and it&#x27;s not clear if ARC is really a game-changer for any serious applications, but it seems interesting at least.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=steveklabnik" target="_blank">steveklabnik</a>   <span class="timeago" data-date="2021-08-17 15:52:47 &#43;0000 UTC">2021-08-17 15:52:47 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            (Rust does not do automatic reference counting)
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=" target="_blank"></a>   <span class="timeago" data-date="2021-08-18 17:20:45 &#43;0000 UTC">2021-08-18 17:20:45 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=dcow" target="_blank">dcow</a>   <span class="timeago" data-date="2021-08-17 17:11:12 &#43;0000 UTC">2021-08-17 17:11:12 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Sure it does: `Arc::new(thing)`
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=steveklabnik" target="_blank">steveklabnik</a>   <span class="timeago" data-date="2021-08-17 17:26:58 &#43;0000 UTC">2021-08-17 17:26:58 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            That is atomic reference counting, not automatic reference counting. With automatic reference counting, you do not need to wrap the variables, and you do not need to increment or decrement the counter. Rust requires that you actively make your values reference counted by wrapping them explicitly, and makes you bump the count explicitly. It uses RAII to decrement the count automatically though.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=alexisread" target="_blank">alexisread</a>   <span class="timeago" data-date="2021-08-17 17:10:15 &#43;0000 UTC">2021-08-17 17:10:15 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            For me, Composita 
<a href="https:&#x2F;&#x2F;concurrency.ch&#x2F;Content&#x2F;publications&#x2F;Blaeser_Component_Operating_System_PLOS_2007.pdf" rel="nofollow">https:&#x2F;&#x2F;concurrency.ch&#x2F;Content&#x2F;publications&#x2F;Blaeser_Componen...</a><p>and ASAP <a href="https:&#x2F;&#x2F;www.semanticscholar.org&#x2F;paper&#x2F;ASAP%3A-As-Static-As-Possible-memory-management-Proust&#x2F;4eb76f9a5b8874328773bf189a22b0975401f373" rel="nofollow">https:&#x2F;&#x2F;www.semanticscholar.org&#x2F;paper&#x2F;ASAP%3A-As-Static-As-P...</a><p>Seem like a good way forward wrt memory management and concurrency, using ASAP inside a component, and delegating concurrency and component cleanup to Composita.<p>Other languages like Maude
<a href="http:&#x2F;&#x2F;maude.cs.illinois.edu&#x2F;w&#x2F;index.php&#x2F;The_Maude_System" rel="nofollow">http:&#x2F;&#x2F;maude.cs.illinois.edu&#x2F;w&#x2F;index.php&#x2F;The_Maude_System</a><p>Are pushing in new directions wrt proof checking.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=wizeman" target="_blank">wizeman</a>   <span class="timeago" data-date="2021-08-17 16:42:01 &#43;0000 UTC">2021-08-17 16:42:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            As far as I understand, the Mercury compiler doesn&#x27;t do compile-time garbage collection (see the LIMITATIONS file).
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=wmanley" target="_blank">wmanley</a>   <span class="timeago" data-date="2021-08-17 16:43:08 &#43;0000 UTC">2021-08-17 16:43:08 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I feel like Kay has taken a rather too narrow view of what counts as programming. IMO here are the breakthroughs in the last 20 (ish) years:<p>1. Stack Overflow - search for your problem, copy and paste the answer.<p>2. git - Revision control that is low enough overhead that you need to have a reason not to use it.<p>3. Open-source software as a commodity - Unless you&#x27;ve got very specific requirements there&#x27;s probably a system that can do most of your heavy lifting.  (Almost) no-one writes their own JSON parsers or databases or web frameworks.  Using open-source software is low overhead and low risk compared to engaging with some vendor for the same.<p>4. Package managers - By making it easy to include other peoples code we lower the bar to doing so.<p>The common thread here is code-reuse.  None of the above are programming languages, but all have driven productivity in building systems and solving problems.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=orthoxerox" target="_blank">orthoxerox</a>   <span class="timeago" data-date="2021-08-17 21:11:06 &#43;0000 UTC">2021-08-17 21:11:06 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Code reuse was the holy grail of the 90&#x27;s. People expected classes to be the unit of code reuse, then enterprise services, then after a dozen years of disillusionment we finally got the recipe right.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-17 22:49:39 &#43;0000 UTC">2021-08-17 22:49:39 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            We finally got the recipe right?<p>How? With micro-services? Or Kubernets clusters?<p>Or copy-paste from SO?<p>Or is it more about Linux packages? Maybe NPM?<p>I&#x27;m really not sure we&#x27;ve got this right by now.<p>Actually everything is over and over rewritten. May it be because of the language used, may it be because of frameworks, or architectures.<p>Polyglot runtimes that could enable true code reuse at least across language boundaries (like GraalVM) are just emerging.<p>For the higher build blocks though there&#x27;s still nothing to enable efficient reuse. (People try of course. So mentioning micro-services was no joke actually).
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=citrin_ru" target="_blank">citrin_ru</a>   <span class="timeago" data-date="2021-08-17 21:43:45 &#43;0000 UTC">2021-08-17 21:43:45 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; Stack Overflow<p>Its blessing and a curse. I think software would be better if coders read mans and other documentation more often (and standards like RFC where it is applicable).<p>&gt; git - Revision control that is low enough overhead that you need to have a reason not to use it.<p>RCS - 1982
CVS - 1990<p>They are limited compare to git, but they perform the main function - track changes in text files allowing to see previous versions, a diff for each change, commit messages. CVS compare to tarballs for each release (or worse to a mess of files .bak, .bak2 e. t. c.) is a breakthrough. Subversion, Mercurial, git is IMHO just evolution of earlier VCS.<p>&gt; Package managers - By making it easy to include other peoples code we lower the bar to doing so.<p>CPAN - 1993
FreeBSD pkg_add - 1993<p>&gt; Open-source software as a commodity<p>Here I fully agree. Opensource started to get some traction 20ish years ago (probably thanks to more widely available Internet and support from corporations like IBM), but its use is still growing.<p>When I look back it seems to me that 1990s were very fruitful and the next 20 years progress in software was somewhat slower, but progress in hardware enabled previously impossible stuff without revolutionary changes in software.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=wmanley" target="_blank">wmanley</a>   <span class="timeago" data-date="2021-08-17 22:59:24 &#43;0000 UTC">2021-08-17 22:59:24 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The point was that these were either dismissed or weren&#x27;t considered by Kay when describing breakthroughs in computer programming.  They aren&#x27;t breakthroughs in computer programming languages, but IMO are breakthroughs in computer programming.<p>&gt; RCS - 1982 CVS - 1990<p>I don&#x27;t accept CVS as a breakthrough in the same way as git has been.  Back in 2000 - 10 years after CVS - using source control wasn&#x27;t a given. We had articles like &quot;The Joel Test&quot;[1] encouraging teams to use source control. CVS was a pain to set up and limited once you did. Thanks to git (and DVCS in general) using source control is the default for 1 person throwaway projects up to projects with thousands of contributors and million lines of code.<p>[1]: <a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;08&#x2F;09&#x2F;the-joel-test-12-steps-to-better-code&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;08&#x2F;09&#x2F;the-joel-test-12-s...</a>
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=setpatchaddress" target="_blank">setpatchaddress</a>   <span class="timeago" data-date="2021-08-18 00:37:15 &#43;0000 UTC">2021-08-18 00:37:15 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            SVN fixed a lot of the issues with CVS, FWIW; setup, maintenance, robustness were much improved. But, yes, git was a major breakthrough. Even if you ignore the advantages of a DVCS and git&#x27;s raw speed, git provides the ability to branch freely, with reasonable confidence that you can merge without spending days reconstructing your divergent source (&quot;merge hell&quot;).
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=citrin_ru" target="_blank">citrin_ru</a>   <span class="timeago" data-date="2021-08-18 09:03:36 &#43;0000 UTC">2021-08-18 09:03:36 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; We had articles like &quot;The Joel Test&quot;[1] encouraging teams to use source control.<p>IMHO source control used more widely nowadays not thanks to git per se,  but thanks to availability of free VCS hosting platforms like github.com<p>Subversion IMHO is more beginner friendly than git, but we AFAIR didn&#x27;t have good subversion platforms (with cheap of free private repos). Sourceforge added SVN in 2006 (which is late), but sourceforge GUI is an abomination and there are reasons not to trust it: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SourceForge#Controversies" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SourceForge#Controversies</a>
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=hnfong" target="_blank">hnfong</a>   <span class="timeago" data-date="2021-08-18 16:01:29 &#43;0000 UTC">2021-08-18 16:01:29 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I suspect this has a lot to do with the architecture of git allowing relatively &quot;dumb&quot; servers. To run a git server, you only need the capacity to receive, serve and compare git hashes and blobs.<p>For SVN at least (last I used it), the server is expected to perform all sorts of potentially expensive operations (esp. for large repos): diffs, merges, branches, etc. since the client does not have the full repo&#x2F;history. Given at the time computing power was less cheap, it would mean that hosting SVN services incurred a non-trivial cost.<p>(And IIRC CVS was so bad that I don&#x27;t think anyone in their right mind should actually try to host a free&#x2F;cheap service around it.)<p>Also, initial versions of SVN was released around 2004, while git 1.0 was technically in 2005. It took a while for people to get used to git, but given its technical superiority (and its momentum given Linus&#x27; approval) and being less demanding on the server side to host, hosting for git was a correct decision to make anyways.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=cambaceres" target="_blank">cambaceres</a>   <span class="timeago" data-date="2021-08-18 12:04:01 &#43;0000 UTC">2021-08-18 12:04:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; I think software would be better if coders read mans and other documentation more often (and standards like RFC where it is applicable).<p>MAYBE the quality on average would increase, but less software would definitely be created.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=kenjackson" target="_blank">kenjackson</a>   <span class="timeago" data-date="2021-08-17 21:28:06 &#43;0000 UTC">2021-08-17 21:28:06 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            YouTube.  My son learns a lot of his programming from searching YouTube and watching videos.  Doesn&#x27;t seem like it would be high density, but I&#x27;m amazed that there are really good videos&#x2F;tutorials on pretty obscure topics.  And since all YouTube videos have dates, it&#x27;s actually easier to find current tutorials.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=josephcsible" target="_blank">josephcsible</a>   <span class="timeago" data-date="2021-08-17 21:59:17 &#43;0000 UTC">2021-08-17 21:59:17 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Are those tutorials good because they&#x27;re videos, or despite being videos? I&#x27;m inclined to believe the latter. What sort of content is there in programming lessons that wouldn&#x27;t be better presented as text?
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=kenjackson" target="_blank">kenjackson</a>   <span class="timeago" data-date="2021-08-18 02:23:52 &#43;0000 UTC">2021-08-18 02:23:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            They are probably better as videos.  For example for Roblox Studio, the content in videos is better as it is clear exactly what you need to do.<p>More importantly the content is easier to produce as a video, which allows a lot more content to be generated.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=scns" target="_blank">scns</a>   <span class="timeago" data-date="2021-08-18 06:46:25 &#43;0000 UTC">2021-08-18 06:46:25 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            They are more easily accessible via one interface, instead of sifting through search engine results.<p>Disclaimer: prefer text myself
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=AnimalMuppet" target="_blank">AnimalMuppet</a>   <span class="timeago" data-date="2021-08-17 18:02:16 &#43;0000 UTC">2021-08-17 18:02:16 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I would add:  Better, more complete libraries shipping standard with languages.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 14:53:25 &#43;0000 UTC">2021-08-17 14:53:25 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I think Kay&#x27;s complaint about engineering rigor ignores the explosive growth of programming. Sure, bridge-builders have rigor; there&#x27;s also probably about the same number of them today as there were 50 years ago.<p>The number of programmers has grown by at least two, maybe three orders of magnitude over the last half century. And more importantly, almost anyone can do it. A kid whose closest approach to structural engineering is building a balsa bridge for a weight competition can also write and release an app for Android or iOS that will be seen by millions. Even if it&#x27;s not a success, it&#x27;s still just as real a program as MS Office.<p>That level of access guarantees amateur-level code, and the rigor Kay is suggesting would kill the software industry as we know it.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=DubiousPusher" target="_blank">DubiousPusher</a>   <span class="timeago" data-date="2021-08-17 15:21:05 &#43;0000 UTC">2021-08-17 15:21:05 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Yeah and I&#x27;ll tell you, as someone wbo gets to look at a lot of those CAD models that are suposedly introducing rigor, they&#x27;re often in exactly the same kind of condition as internal codebases.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Jtsummers" target="_blank">Jtsummers</a>   <span class="timeago" data-date="2021-08-17 16:16:18 &#43;0000 UTC">2021-08-17 16:16:18 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; That level of access guarantees amateur-level code, and the rigor Kay is suggesting would kill the software industry as we know it.<p>I don&#x27;t believe this follows. The level of rigor he&#x27;s lamenting could be constrained to certain categories of software, based on their impact or information content. Amateur or informally specified systems can still satisfy everything else. There is no reason for most systems that don&#x27;t touch PII or critical systems or other similar categories of software to have serious engineering behind them if people don&#x27;t want them to.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 19:18:20 &#43;0000 UTC">2021-08-17 19:18:20 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Sure, I meant if that rigor was applied to the whole software industry, not selectively, exactly as you say. And that level of rigor <i>is</i> applied sometimes. The most  rigorous example I know of is the Space Shuttle guidance system (I think that was it; I read about it twenty years ago). Two independent teams write two entirely separate programs, and then in practice (again, from memory) two versions of program A run, and if they disagree program B is the tie breaker.<p>Also their QA process was <i>completely</i> adversarial. Finding a bug was a major success for QA, and a major failure for the dev team. They found something crazy like 1 bug per million lines of code.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=joe_the_user" target="_blank">joe_the_user</a>   <span class="timeago" data-date="2021-08-17 21:27:24 &#43;0000 UTC">2021-08-17 21:27:24 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            <i>...the rigor Kay is suggesting would kill the software industry as we know it.</i><p>You say that like it&#x27;s a bad thing.<p>Anyone&#x27;s plans to make software sane would kill the software industry as people love and hate it. A substantial portion of this industry involves supporting horrific abortions of a system that seem to live far too long. That includes the functional programming people and anyone who believes some method of theirs will produce an explosion of productivity. Hopefully, the effect will be people quickly rewriting old systems to be sane and creating many new system.<p>Unfortunately, such starry eyed idealism is unlikely to be realized and the rolling a 1000 pounds of jello up a hill jobs are safe. But this kind of idealism is still needed to motivate the systems builders so it&#x27;s not a complete loss.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=scns" target="_blank">scns</a>   <span class="timeago" data-date="2021-08-18 07:01:14 &#43;0000 UTC">2021-08-18 07:01:14 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; the rolling a 1000 pounds of jello up a hill jobs are safe<p>I know that is frowned upon here but boy was that funny.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Joker_vD" target="_blank">Joker_vD</a>   <span class="timeago" data-date="2021-08-17 15:55:22 &#43;0000 UTC">2021-08-17 15:55:22 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Well, rigor and quality in building industry are location dependent. I&#x27;ve read a blog of a builder who describes how architects regularly produce dangerous (too thin or just simply missing load-bearing beams) or straight up impossible (gable of negative size, yep) designs. The solution is that the builders just build whatever makes sense and sometimes the contractors simply don&#x27;t notice.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=Fantosism" target="_blank">Fantosism</a>   <span class="timeago" data-date="2021-08-17 19:13:28 &#43;0000 UTC">2021-08-17 19:13:28 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I&#x27;m ignorant in this domain, but wouldn&#x27;t it be up to the structural engineer to make sure the plans are sound? I always thought that architects dream it up and engineers are responsible for the physics.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=DennisP" target="_blank">DennisP</a>   <span class="timeago" data-date="2021-08-17 21:01:06 &#43;0000 UTC">2021-08-17 21:01:06 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Note that Kay actually complained about lack of “real engineering <i>vigor</i>” which maybe was a typo or maybe not.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=lordnacho" target="_blank">lordnacho</a>   <span class="timeago" data-date="2021-08-17 21:28:26 &#43;0000 UTC">2021-08-17 21:28:26 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            My problem with this is it sort of implicitly assumes that languages are the unit of progress. It&#x27;s unlikely that we will get progress solely by coming up with better languages, it&#x27;s more like different people invent different tools to suit different problems. In the explosion, we are more likely to find what we need.<p>I don&#x27;t think I&#x27;ve ever used just one language for a project.<p>The progress at least personally is that there are now so many resources to use a bunch of different languages to knit together a solution that a lot more can get done. You can write your low latency code in a variety of languages, and ship the data via a web server to a browser or a mobile app. For every part you have several choices of tech to use, and they&#x27;re realistic choices with lots of help online. Almost everything is available for free, so you can try all sorts of libs without committing to one. There&#x27;s no longer a need to sit down with a textbook and learn a bunch of stuff before starting, you can just jump in with a brief tutorial and explore the language or lib as you discover them.<p>The plethora of choices also teaches you a lot about languages in general, because you see so many that you can start to make generalizations.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=N1H1L" target="_blank">N1H1L</a>   <span class="timeago" data-date="2021-08-17 17:18:50 &#43;0000 UTC">2021-08-17 17:18:50 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            LLVM could very well be thought of as major breakthrough. The intermediate representation format has enabled so many compiler and languages now, that it&#x27;s pretty insane in my opinion.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=mikewarot" target="_blank">mikewarot</a>   <span class="timeago" data-date="2021-08-17 15:23:17 &#43;0000 UTC">2021-08-17 15:23:17 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Metamine represents the latest breakthrough in programming, it offers a mix of tradition declarative programming and reactive programming. The &quot;magical equals&quot; for lack of a better term, lets you do &quot;reactive evaluation&quot;, the opposite of lazy evaluation.<p>If any of the terms that a term depend on change, the result is updated, and all it&#x27;s dependencies, etc.  You can use the  system clock as a term, thus have a chain of things that update once a second, etc.<p>Being able to use both reactive and normal programming together without breaking your brain is a whole new level of power.<p>It&#x27;s brilliant stuff, and it seems to have been yoinked from the internet. 8(<p>Here&#x27;s a previous thread about it:  <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27555940" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27555940</a>
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-18 00:20:04 &#43;0000 UTC">2021-08-18 00:20:04 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Dataflow languages are going back to the late 70ies.<p>Think Excel. ;-)<p>But I agree it&#x27;s an under-explored branch of programming.<p>Event-&quot;handlers&quot; are by the way dataflow based in QML. Dataflow shines in GUIs.<p>But not only there:<p><a href="https:&#x2F;&#x2F;enso.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;enso.org&#x2F;</a>
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=pharmakom" target="_blank">pharmakom</a>   <span class="timeago" data-date="2021-08-17 16:33:12 &#43;0000 UTC">2021-08-17 16:33:12 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Can’t this be expressed as a library in Haskell or even F# though?
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=AnimalMuppet" target="_blank">AnimalMuppet</a>   <span class="timeago" data-date="2021-08-17 18:11:04 &#43;0000 UTC">2021-08-17 18:11:04 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            That style sounds like it&#x27;s mutating variables when other variables change (that is, mutate).  That doesn&#x27;t sound like a good fit for Haskell...
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=kian" target="_blank">kian</a>   <span class="timeago" data-date="2021-08-17 20:32:44 &#43;0000 UTC">2021-08-17 20:32:44 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Haskell is great at mutating variables. Reactive programming was even pioneered in it. It&#x27;s just that the Monads that allow you to do this are somewhat like sticky tar - everything they touch becomes a part of them.<p>The traditional structure of Haskell programs is to build a pure functional &#x27;core&#x27;, and layer around that the &#x27;sticky&#x27; parts of the code that need to interact with the outside world.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=AnimalMuppet" target="_blank">AnimalMuppet</a>   <span class="timeago" data-date="2021-08-17 20:42:54 &#43;0000 UTC">2021-08-17 20:42:54 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            OK, but the &quot;reactive&quot; programming sounds like how you build the core.  So I still question whether that style fits well with Haskell.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=pharmakom" target="_blank">pharmakom</a>   <span class="timeago" data-date="2021-08-17 22:47:38 &#43;0000 UTC">2021-08-17 22:47:38 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Haskell has do notation and monads (F# has computation expressions, which are similar). These allow you to implement things as libraries that in most other languages would require changes to the compiler. Lisp macros can do it too.<p>You could push the reactivity monad right down to the core of your application to get the benefits of this reactive language.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=machiaweliczny" target="_blank">machiaweliczny</a>   <span class="timeago" data-date="2021-08-17 20:21:59 &#43;0000 UTC">2021-08-17 20:21:59 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            So it&#x27;s like MobX in UI world?
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=agent327" target="_blank">agent327</a>   <span class="timeago" data-date="2021-08-17 18:43:38 &#43;0000 UTC">2021-08-17 18:43:38 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Since I left university (eighties) I have only been positively impressed by two languages. One was the Wolfram language. I haven&#x27;t used it; I&#x27;m just going on the demo here, but the idea of having not just a powerful language, but also a massive database with useful information to draw from, seems to elevate it above the usual sad collection of new ways to spell variable declarations and loops.<p>The other is Inform. I haven&#x27;t used that either, and of course it is highly domain-specific, but within that domain it seems a pretty damn cool way to write text adventures.<p>All of the graphical programming systems seem to fail the moment they scale up above what roughly fits on one screen. Labview is a disaster once it is more than just a few boxes and lines.<p>And everything else is, as far as I can tell, just the same bits and pieces we already had, arranged slightly differently. We were promised hyper-advanced fifth-generation programming languages, but the only thing that seems to come close is Wolfram, and that&#x27;s hardly mainstream.<p>I&#x27;m occasionally wondering if the whole field might not improve mightily if we stopped focusing so much on languages, and instead focused on providing powerful, easy to use, elegant, well-documented APIs for common (and less common) problems. Using something like OpenSSL, or OpenGL, or even just POSIX sockets, is just an exercise in (largely unnecessary) pain.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=feoren" target="_blank">feoren</a>   <span class="timeago" data-date="2021-08-17 20:58:35 &#43;0000 UTC">2021-08-17 20:58:35 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It sounds like you and Alan Kay are both expecting novel problems to be solved by new programming languages. That is an extremely inefficient way to do it: you need to come up with new compilers, documentation, standard libraries, communities, etc. Instead, programming languages have become general enough that most new problems are being solved within existing languages, instead of by inventing new ones.<p>I have no idea what a &quot;hyper-advanced fifth-generation programming language&quot; is even supposed to look like.<p>&gt; I&#x27;m occasionally wondering if the whole field might not improve mightily if we stopped focusing so much on languages, and instead focused on providing powerful, easy to use, elegant, well-documented APIs for common (and less common) problems.<p>But a programming language is nothing but a well-documented API! How would your suggested solution even differ from a programming language?
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=agent327" target="_blank">agent327</a>   <span class="timeago" data-date="2021-08-18 09:13:31 &#43;0000 UTC">2021-08-18 09:13:31 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            That&#x27;s not quite it. Let me explain... The first computer language I used was BASIC. It was excellent for what it was, but clearly it had a limit on how much you could do with it, on account of it missing amenities like named functions, variable scopes, etc. A &#x27;function&#x27; was simply a line further down the program that you branched to using GOSUB. And there was only one scope, which was fine since the space available for actually writing programs was a microscopic 23KB anyway. It had for-loops, but GOTO was still very much present as a tool to control program flow.<p>Moving on from there, I learned Pascal, which was clearly a major step up in terms of what you could achieve. Using the primitives available in Pascal (structured programming, named functions, scopes, etc.), it is possible to write larger programs than you can in BASIC: the higher level of abstraction makes it easier to reason about larger programs.<p>From there C++ was another step up: the ability to define objects and encapsulate a great deal of implementation detail is another weapon in your toolbox to combat chaos, thus allowing you to write ever more complex programs without losing control over what they are doing.<p>And then... there was nothing. There appears to be no step beyond object-orientation that lets you create even larger programs with even less effort. There may be languages that are syntactically easier than C++ (although after using it for a quarter century it no longer bothers me), but they just hide minor implementation details, at the cost of lower performance. That&#x27;s not greater abstraction, it&#x27;s just greater convenience.<p>What we were all hoping for was that next step: languages that provided an even higher level of abstraction, allowing you to create even larger programs without losing the ability to reasoned about them. This was what 5GL promised, but which we didn&#x27;t get because nobody could figure out what they would look like. Apparently we have reached a maximum level of abstraction that we can express with source.<p>So the progression of computer languages looks somewhat like this: 1GL (plain assembly), 2GL (unstructured languages like BASIC), 3GL (structured languages like Pascal), 4GL (object-oriented languages), 5GL (not, as of yet, invented). Each level represents a clear step up in terms of abstraction, and after four steps we seem to have run out of steam, and are now mostly busy reinventing things we already had with slightly different syntax. To me, at least, that&#x27;s a disappointment.<p>My disappointment with available APIs is perhaps simply because I program a lot in C++, which inevitably means having to deal with an anemic standard library (there&#x27;s not even a standardized socket interface in there), and a wild array of C-libraries. Some of these are very good, with an elegant interface design and excellent documentation, but many are just painfully bad, with virtually no documentation, and apparently every effort made to confuse the hell of out their potential users. Really, some of this could be so, so much better...
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=hnfong" target="_blank">hnfong</a>   <span class="timeago" data-date="2021-08-18 16:23:12 &#43;0000 UTC">2021-08-18 16:23:12 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Isn&#x27;t abstraction merely an &quot;indoctrinated&quot; kind of convenience?<p>Surely you can, with a huge amount of inconvenience, achieve in Pascal what you routinely do in C++, by passing &quot;self&quot; into function calls and manually implementing vtable lookups? :)<p>(You might have a point with C++ templates but that&#x27;s just saving yourself the trouble of a bunch of copy and pasta....)<p>Similarly, the &quot;2GL&quot; to &quot;3GL&quot; transition merely gives you the convenience of not having to maintain a call stack. There&#x27;s no magic, you just save yourself trouble of writing boilerplate code with pushing and popping pointers and stack variables.<p>I would argue that the only reason it&#x27;s considered a &quot;paradigm shift&quot; is merely because you were &quot;indoctrinated&quot; into thinking those advancements were so great that they were &quot;more than&quot; mere convenience. But, at least in retrospect, they are _trivial_ when compared with the advancements made in recent years (eg. Garbage Collection, Rust&#x27;s safe memory management, import tensorflow, etc.). And while the old school programming language advancements surely boost programmer productivity and accuracy, I don&#x27;t think it&#x27;s fair to say they&#x27;re more important than say the convenience of an &quot;import fancypackage&quot; that does 90% of the work for you.<p>Perhaps the form of improvement is often not in a new programming language (because perhaps classical languages are &quot;good enough&quot; for most cases), but I know I wouldn&#x27;t enjoy programming with the tools available 20 years ago.<p>PS: I suspect your C++ perspective might also have tinted your perspective a bit. For the examples I gave as more recent advancements (i.e. GC, Rust, TF), they aren&#x27;t (readily) available in C++. Sure you can say you prefer the speed of C++ which is entirely fair, but you might be pleasantly surprised if you looked outside.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=agent327" target="_blank">agent327</a>   <span class="timeago" data-date="2021-08-19 12:20:48 &#43;0000 UTC">2021-08-19 12:20:48 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Indoctrination: perhaps it is, but I don&#x27;t think so, since other people make largely the same distinction, as witnessed by a series of articles on wikipedia (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fifth-generation_programming_language#Previous-generation_languages" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fifth-generation_programming_l...</a>). Although they have a slightly different definition of 4GL than the one I used.<p>Ultimately Turing-completeness means there is no difference in what you can achieve with various languages. What matters are other things: the convenience of getting the work done, performance, etc. In my experience Pascal and C++ really do differ significantly, with C++ allowing you to automate a hell of a lot more than Pascal would.<p>I disagree that GC is a more meaningful step forwards than, say, structured programming - this is something that is now so pervasive that it is no longer recognized for the revolution that it really was. GC is just one method of freeing memory, but it&#x27;s not the only one; C++&#x27;s RAII does the same, and tracks any resource you care for, not just memory. I totally agree on the importing though. Arguably vcpkg has been a game changer in that sense.<p>Programming 20 years ago wasn&#x27;t all that bad, really. Figuring something out usually meant reading a book. There were fewer useful libraries around and they were less capable, but on the other hand, they also weren&#x27;t as ridiculously complex as today&#x27;s libraries sometimes are.<p>And I&#x27;ll readily admit that C++ informs my comments ;-) I mean, I&#x27;ve been writing C++ since 1996 or so, and for most of that, pretty much full time...
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=feoren" target="_blank">feoren</a>   <span class="timeago" data-date="2021-08-18 18:29:48 &#43;0000 UTC">2021-08-18 18:29:48 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            What I&#x27;ve observed is that programming languages have significantly caught up with the math behind them. And it&#x27;s not uncommon for some of the nearly-cutting-edge math to be hundreds of years old, or more. I recently looked into algorithms for finding the GCD of two numbers, and Euclid&#x27;s algorithm from 300 BC is still basically the best way to do it (with an optimization for our binary representation happening in 1967). As programming languages catch up to the underlying mathematical theory, they&#x27;re going to start progressing at the pace of math breakthroughs. That kinda sounds like a good thing to me.<p>I don&#x27;t see object-oriented languages as the pinnacle. Notably missing from your list are functional languages, which I also don&#x27;t see as the pinnacle, but rather &quot;beside&quot; OO langs. A 5GL to me is one that incorporates the best of each paradigm. I generally program in C# and TypeScript, and I&#x27;m constantly switching between an imperative style, an OO style, and a functional style. C# is almost my ideal language; its type system is just a little too weak. Perhaps it&#x27;s a 4.5G language. But let&#x27;s look at what you can do with it:<p>* Strong OO support<p>* First-class functions (functions-as-data)<p>* Strong support for reflection, allowing powerful IoC and types-as-data<p>* Good generic type support (reified! Yay!)<p>* Generators with yield<p>* Async&#x2F;await flow programming, including &quot;yield async&quot; mixing the two<p>* Low-level bit manipulation, arrays of structs (certain memory guarantees), unchecked operations when you need them, and other C-style concepts<p>* LISP-style macro manipulation (code-as-data) using Expressions (under-appreciated IMO)<p>* No higher-kinded types :(<p>* LINQ, if you&#x27;re into it ... but I prefer fluent because it&#x27;s more extensible and language-idiomatic (although you can write your own limited LINQ-style methods)<p>Add in higher-kinded types and how could you not call that a 5GL? I honestly don&#x27;t know what else you could possibly want from a programming language, except maybe Rust&#x27;s borrow checking (which frankly is a recent breakthrough in computer programming, kinda challenging the premise of this whole thing).<p>My next big idea is a programming language whose type system is written with the &quot;same sauce&quot; as the language itself. So the output of a &quot;program&quot; could be the type system for another program. You could write your software in &quot;tiers&quot; of progressively more strict&#x2F;knowledgeable type systems. That&#x27;s one thing I haven&#x27;t seen before that sounds neat, but who knows if it&#x27;s actually useful.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=jimbokun" target="_blank">jimbokun</a>   <span class="timeago" data-date="2021-08-17 16:30:29 &#43;0000 UTC">2021-08-17 16:30:29 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I think the biggest programming productivity boosts since 1984 haven&#x27;t been about programming languages, but about tools.<p>Specifically, distributed version control and dependency management tools.<p>Being able to collaborate with developers anywhere in the world, and being able to pull in any library with a single declarative line in a configuration file, increases productivity more than any improvement to a programming language ever could.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ComodoHacker" target="_blank">ComodoHacker</a>   <span class="timeago" data-date="2021-08-17 16:40:44 &#43;0000 UTC">2021-08-17 16:40:44 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt;Specifically, distributed version control and dependency management tools.<p>Indeed, without these tools dependency hell wouldn&#x27;t be possible! &#x2F;s
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=kenjackson" target="_blank">kenjackson</a>   <span class="timeago" data-date="2021-08-17 21:29:20 &#43;0000 UTC">2021-08-17 21:29:20 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Oh, we still had it!
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=hnfong" target="_blank">hnfong</a>   <span class="timeago" data-date="2021-08-18 16:31:13 &#43;0000 UTC">2021-08-18 16:31:13 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Evidence - This started happening in the 1990s (latest) before tools like git and npm was a thing:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DLL_Hell" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DLL_Hell</a>
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=chasd00" target="_blank">chasd00</a>   <span class="timeago" data-date="2021-08-17 20:03:50 &#43;0000 UTC">2021-08-17 20:03:50 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I agree, could you imagine doing something like Java Spring without maven or the equivalent? It wouldn&#x27;t be possible.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=mark_l_watson" target="_blank">mark_l_watson</a>   <span class="timeago" data-date="2021-08-17 14:36:05 &#43;0000 UTC">2021-08-17 14:36:05 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Nice read. Personally, I am not as unhappy with the state of tooling. With LSP, many programming languages are getting better VSCode, Emacs, Vi, etc. support. XCode is actually nice to use, on a fast M1 Mac. I think wide adoption of deep learning is the biggest breakthrough in recent years.<p>EDIT: I have used Lisp heavily for 40 years, and I have done a few Smalltalk projects.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=RivieraKid" target="_blank">RivieraKid</a>   <span class="timeago" data-date="2021-08-17 22:35:23 &#43;0000 UTC">2021-08-17 22:35:23 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Maybe calling these &quot;breakthroughs&quot; is a stretch, but anyway...<p>Swift. I think that this is the best general purpose language ever created. By &quot;best&quot; I mean that it has the highest productivity (which is determined by readability, static safety, expressiveness, etc.) after normalizing for factors outside of the language spec, e.g. tooling, libraries, compilation and runtime speed.<p>React and Svelte. The first breakthrough was React, the second generation is Svelte and similar frameworks.<p>Async &#x2F; await. This is a major improvement to the readibility and mental model simplicity of the most common type of concurrency code.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=svachalek" target="_blank">svachalek</a>   <span class="timeago" data-date="2021-08-17 20:58:50 &#43;0000 UTC">2021-08-17 20:58:50 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Early programming language advancements were about abstracting away the basic repetitive stuff (function call stack manipulation) and the hardware details (register selection, memory addresses). They did it in a way that was minimally &quot;leaky&quot;; debugging a C program you may be aware of the call stack and registers, but most of the time you&#x27;ll be just fine working at the abstraction level of function parameters and local variables.<p>Since then we&#x27;ve added tons more boilerplate and hardware to the standard application deployment, it runs over multiple servers and clients using various network protocols, interacts with databases and file systems, etc. But modern solutions to these are mostly code generation and other leaky layers, it&#x27;s likely you can&#x27;t debug a typical problem without reading or stepping through generated code or libraries.<p>What I&#x27;d like to see in a new programming language is some abstraction of an application that has persistent data and is distributed, with the details being more or less compiler flags. And comes with debugging tools that allow the programmer to stay at that level of abstraction. But most new language announcements come down to some new form of syntactic sugar or data typing.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=blippage" target="_blank">blippage</a>   <span class="timeago" data-date="2021-08-18 12:06:55 &#43;0000 UTC">2021-08-18 12:06:55 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I think that programming is the most confused discipline there is. I&#x27;ve mentioned this in previous posts. In any other field there is usually an established body of knowledge, either in science of professions like accountancy.<p>In programming we&#x27;re still arguing about whether the debits should go on the left and credits on the right, or vice versa. By that I mean, facetiously, we&#x27;re still arguing about what programming language to use.<p>Most new sciences - e.g. electronics - gather a mature body of knowledge relatively quickly. We know exactly how transistors work and how to use them, for example. Nobody argues about how to calculate the current flowing through a wire.<p>This, to some extent, happened in programming, especially early, but the matter still seems far from settled.<p>Some poster on here once noted that there are no new paradigms in programming. Their argument is that not functional, OO, or other invention, as good as they are, constitute a paradigm shift. A paradigm shift is so fundamental that it uproots our whole conceptions about how the universe works; like the shift away from using epicycles to describe the motion of planets to using a theory of gravitation.<p>I&#x27;ve been tinkering around with microcontrollers lately, and it has given me a perspective that I suspect many don&#x27;t have. I like C++, and I think it&#x27;s suitable for high-level programming, due to things like deterministic garbage collection and niceties like strings and vectors.<p>But I&#x27;ve come to the conclusion that C++ is marginal, at best, on microcontrollers. Things tend to be far more static, so these niceties do not bulk large. But C++ also needs extra fiddle if you start from scratch. Things like exceptions need effort to implement.<p>C is low-level. You get to build things block by block. If your microcontroller supports some nifty hardware acceleration feature, then you can use that.<p>And that&#x27;s the thing. A high-level language is an abstraction. It can&#x27;t decide what should happen at a very low level. So you have a convenience, but you also take a hit.<p>So perhaps looking for a better language is a chimera, because how you do something is dependent on what it is you&#x27;re trying to do. It also means that C is never likely to go away as a language, and that C++ was a clever idea in that it built on C.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=hnfong" target="_blank">hnfong</a>   <span class="timeago" data-date="2021-08-18 16:39:19 &#43;0000 UTC">2021-08-18 16:39:19 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; Most new sciences - e.g. electronics - gather a mature body of knowledge relatively quickly. We know exactly how transistors work and how to use them, for example. Nobody argues about how to calculate the current flowing through a wire.<p>Ever since we made computers fast enough to implement basic things in the 1980&#x2F;1990s, the debate has never been a &quot;scientific&quot; one. It&#x27;s all about programmer preference and psychology.<p>Equations about electricity is relatively simple. Yet we don&#x27;t have equations about programmer brains.  The only way we can &quot;scientifically&quot; experiment with programming languages is to invent new languages&#x2F;features and see how programmers react. Do they make fewer mistakes? Do they see increased productivity? Do they &quot;like&quot; it or even swear by it?<p>To a very large extent (more-so than most would imagine), trying to pin down &quot;programming best practices&quot; is like trying to set a standard for writing novels. You have common tropes and literary devices (aka &quot;design patterns&quot;), but the expressiveness of languages (both human and computer) makes it hard to make final, scientific conclusions.<p>The electricity on a wire thing is really much more simpler.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=DesiLurker" target="_blank">DesiLurker</a>   <span class="timeago" data-date="2021-08-17 21:25:52 &#43;0000 UTC">2021-08-17 21:25:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I&#x27;d say being able to program GPUs as general purpose compute devices &amp; general SIMD vectorization in high level language is pretty significant. it has opened up many applications like machine learning previously unavailable.<p>IMO some C++20 features like coroutines rank pretty high in introducing new ways of programming.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ColinWright" target="_blank">ColinWright</a>   <span class="timeago" data-date="2021-08-17 21:36:55 &#43;0000 UTC">2021-08-17 21:36:55 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I have a question about that, and despite asking in several places, and reading lots of documents, I&#x27;ve ever been able to find an answer that makes sense.  Maybe you can help me.<p>I have an algorithm that I used to run on a SIMD machine.  It&#x27;s a single, simple algorithm that I want to run on lots of different inputs.  How can I run this on a GPU?  From what I read about GPUs it should be possible, but nothing I&#x27;ve read has made any sense about how to do it.<p>Can you point me in a suitable direction?<p>My contact details are in my profile if you&#x27;d like to email to ask for more information.<p>Thanks.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=emllnd" target="_blank">emllnd</a>   <span class="timeago" data-date="2021-08-17 22:56:38 &#43;0000 UTC">2021-08-17 22:56:38 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Hi Colin. A few ways to go about it, requires getting some initial tedium done to get started. I would recommend the course <a href="https:&#x2F;&#x2F;ppc.cs.aalto.fi&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ppc.cs.aalto.fi&#x2F;</a> as a resource, goes through specifics of implementing an example data-crunching program using both a vectorized&#x2F;SIMD CPU approach (ch1-2) and a GPU approach (ch4, using Nvidia Cuda specifically). Another approach would be to upload data to GPU in dx&#x2F;vulkan&#x2F;metal&#x2F;opengl buffers or textures and run shaders on them, plenty of resouces out there but I understand it’s tricky to find a suitable one. Happy to discuss more
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=DesiLurker" target="_blank">DesiLurker</a>   <span class="timeago" data-date="2021-08-18 05:15:49 &#43;0000 UTC">2021-08-18 05:15:49 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I think you&#x27;d be better served by using something like OpenCL. especially if it was already running on simd core then it should be relatively straightforward to port to openCL. the mental model to follow would be to think of a gpu as a collection of identical simd machines that are programmed in simplified version of C.<p>thinking further, if you have never programmed gpgpu processors you may be better off porting your code using NVIDIA CUDA (assuming you are targeting desktop graphics). it had better tools and overall a better ecosystem.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=abetusk" target="_blank">abetusk</a>   <span class="timeago" data-date="2021-08-17 17:22:26 &#43;0000 UTC">2021-08-17 17:22:26 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It always feels like Alan Kay is wistfully talking about how there could have been an alternate future where he and his ilk would do programming and computer engineering the &quot;right way&quot; and somehow the world has lost it&#x27;s path. He waxes eloquent about how he enabled the genius&#x27;s at Xerox PARC to do deep work and how they changed the world.<p>I find his talks inspiring but I also find it tone deaf that he doesn&#x27;t understand the situation he was in nor does he see how the world has changed. Xerox PARC was, in my opinion, a by product of top down &quot;waterfall&quot; like business practices that he happened to be at the apex of. For most of the rest of us, we have to get by with minimal funding and try to push ideas to an over saturated market.<p>What really irks me is how he still has this view that somehow if all the worlds intellectuals just got together or just got funding, somehow they would come up with the next genius ideas and could deliver it to the rest of the world, like god&#x27;s messengers.<p>Here&#x27;s what he missed:<p>* Free and Open source. It&#x27;s not software that&#x27;s eating the world, it&#x27;s free and open source software that&#x27;s eating the world. Most of the worlds infrastructure runs on FOSS and we&#x27;d be living in a developer hellscape of choosing between which Apple and Microsoft crippling licensing fees we&#x27;d need to pay just to have the privilege of compiling our programs.<p>* Git. Git has allowed project management and software sharing with ease like nothing before. Even though GitHub is a proprietary enterprise, it&#x27;s created massive value to the community through it&#x27;s ease of sharing.<p>* Javascript. Write once run anywhere? Javascript is the only language that comes even close. Data representation that&#x27;s portable? JSON is the only one that comes close. Javascript has it&#x27;s warts but it brings the best of functional languages in a procedural languages skin. Javascript is the only reason I don&#x27;t dismiss functional languages off hand, because Javascript actually makes those concepts useful.<p>* Docker (and perhaps some WebAssembly&#x2F;Javascript environment). I think we&#x27;re closing in the idea that Linux boxes are the analogues of &quot;cells&quot;, where each has their own local environment and can be composed to form larger structures. Linux images may seem bloated now but when space and compute passes a threshold of cheap&#x2F;fast, it won&#x27;t matter.<p>* GPUs. Moores law is alive and well with GPUs. &quot;Out of the box&quot; gets you a 10x-100x speedup on algorithms ported from CPUs. I&#x27;ve heard of 1000x-10000x in some cases. It&#x27;s not just raw performance, it&#x27;s also designing data structures that work on GPUs, are more data centric and are designed for small, independent and highly parallel workloads.<p>And I&#x27;m sure there are many more. I would add cryptocurrency but maybe that falls outside of the &quot;programming&quot; scope.<p>For all his preaching, Alan Kay still doesn&#x27;t &quot;get it&quot;. If there&#x27;s a billion dollar monopoly that has a small, independent research group that has no ceiling to funding and has Alan Kay as it&#x27;s head, great, I&#x27;m sure they&#x27;ll come up with some wonderful ideas. We don&#x27;t live in that world anymore and the playing field has been leveled because of the points above and many more (maybe even more simply just because cheaper compute is available).<p>It never really occurs to Alan Kay that maybe his type of research is not the only way. Better yet, maybe Alan Kay&#x27;s style of research is gone <i>because</i> we&#x27;ve discovered better ways.<p>If Alan Kay really wants to see the worlds next ideas birthed into existence, why isn&#x27;t he at the forefront of free and open source, championing the software that enables people to his type of fundamental research? If you really want a trillion dollar ROI, invest a few million in FOSS.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=DetroitThrow" target="_blank">DetroitThrow</a>   <span class="timeago" data-date="2021-08-17 20:52:24 &#43;0000 UTC">2021-08-17 20:52:24 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I really enjoyed this critique of AK, but you could really stuff docker and javascript into &quot;portability&quot; to include technologies that provide the same benefits to other focuses outside of application programming. Intermediate representations like LLVM and WASM, and even environments like Wine and Linux subsystem for Windows have felt like major paradigm shifts.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 19:26:25 &#43;0000 UTC">2021-08-17 19:26:25 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Write once, run anywhere: I used to demo for LiveCode <a href="https:&#x2F;&#x2F;livecode.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;livecode.com&#x2F;</a> at MacWorld and WWDC where I would code a basic app and build separate single-file standalones for Mac, Windows, and Linux, all while holding my breath.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=bumbada" target="_blank">bumbada</a>   <span class="timeago" data-date="2021-08-17 20:51:01 &#43;0000 UTC">2021-08-17 20:51:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt;If Alan Kay really wants to see the worlds next ideas birthed into existence, why isn&#x27;t he at the forefront of free and open source?<p>He was, he created Smalltalk, released the source code and made it as open as it can be. You can see the source of everything.<p>The only problem was very few people were interested on that. Most children were interested in just one thing: games(the best quality they could get). And adults wanted to run professional programs in their inexpensive machines.<p>He just could not understand why people choose other languages, like C, that were anathema for him, but let people extract all the juice of their cheap computers in order to create and play games and also serious programs that previously only run on mainframes.<p>As an academic with early access to &quot;hundreds of thousand dollars per machine&quot;(and not accounting for inflation), he was too isolated from the rest of the world to understand what happened later.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 15:01:10 &#43;0000 UTC">2021-08-17 15:01:10 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I think to understand the &quot;next&quot; level of programming it&#x27;s important to broaden our definition. &quot;Programming&quot; should be more like &quot;defining a system to turn a specific input from a defined input set into a corresponding action or output.&quot;<p>That&#x27;s too broad, because it includes the formula =A1*2 in Excel. But at some greater level of complexity, an Excel spreadsheet transforms from &quot;a couple formulas&quot; to &quot;a structured tool designed to keep track of our orders and invoices&quot; -- in other words, a program.<p>On that basis, the recent advances include spreadsheets, database tools, and JavaScript along with other scripting languages.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=Too" target="_blank">Too</a>   <span class="timeago" data-date="2021-08-18 07:35:12 &#43;0000 UTC">2021-08-18 07:35:12 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The biggest shift lately is probably on the ops side. The role sysadmin or DBA hardly exists anymore as full-time jobs. With the goals of containerization and avoiding snowflaking giving lots of positive spill-over effects for the developer side as well.<p>Today i can snapshot the volume of my containers, completely format my computer, download and reinstall Ubuntu from scratch. Download and install any IDE and all tools i need, clone a project from github, npm install thousands of dependencies, spin up a docker-compose network with a distributed nosql database and a a few services, commit and push a MR giving relevant test results back from github CI and someone reviewing the code - All in one day. 10-15 years ago (without even considering the difference in download-time) every step here would be at least a day each, involving complicated configurations and often causing non revertible modifications to the host system.<p>Containerization and sandboxing can also be seen as being big enablers for the mobile app stores and untrusted browser applications being able to deploy to clients instantly.<p>I&#x27;d also say UI frameworks are a big deal. Both Windows, Android, iOS and the Web have much more powerful tools than say Win32 or whatever old baseline one wants to compare with. Especially declarative web front end frameworks like React and Vue. Some might call these fad-frameworks, but i for sure can write better web-apps with less than half the number of lines, and with much less spaghetti, compared to what we used to do in 2005 (just close one eye for the webpack complexity), if that&#x27;s not a paradigm shift i don&#x27;t know what is. Unfortunately this hasn&#x27;t always resulted in much better applications for end users when looking at the average app, probably due to lower barrier of entry and race to the bottom.<p>Programming languages, IDEs and tooling overall are miles better than before, even if it&#x27;s hard to pin any specific milestone to where the shift happened, all small gains add up to a big deal on all fronts. C++ is still C++ and Java is still Java but even there a lot of the verbose boilerplate is reduced giving much better ergonomics. Then you&#x27;ve got things like Kotlin, Typescript and other hybrid-dynamic&#x2F;static + hybrid-OO&#x2F;functional languages getting improved and more widespread, Async everywhere, Rust bringing something on the table to finally replace C&#x2F;C++, package managers used by everyone really enabling code-reuse. You now also got almost all popular languages converging and being equally capable doing everything, not one language per use-case.<p>Then there are tons of other cools things like GPGPU, machine learning, big data, EBPF, crypto and security. It&#x27;s just too much to grasp.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=api" target="_blank">api</a>   <span class="timeago" data-date="2021-08-17 16:00:25 &#43;0000 UTC">2021-08-17 16:00:25 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I wouldn&#x27;t call it a breakthrough as the ideas are not new, but I consider Rust to be a major practical advancement that brings ideas into the mainstream that were formerly just for &quot;academic&quot; languages.<p>It&#x27;s the first IMO viable alternative to C and C++ for systems programming <i>ever</i>, and its safety features represent a successful transfer of provable-safety ideas of academia into a practical language that people actually want to use for real stuff.<p>As for true breakthroughs I&#x27;d say the last big one was modern deep learning.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=platz" target="_blank">platz</a>   <span class="timeago" data-date="2021-08-17 16:02:39 &#43;0000 UTC">2021-08-17 16:02:39 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            So if Pizza Hut wants a checkout cart they need to rent a supercomputer to plan the implementation?
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=mlosgoodat" target="_blank">mlosgoodat</a>   <span class="timeago" data-date="2021-08-17 16:27:08 &#43;0000 UTC">2021-08-17 16:27:08 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            He was speaking as if it was still 1980s. Now we have cloud based ML doing the optimization finding.<p>ML will (eventually) be able to generate biz logic code, and most assuredly infrastructure config (a cloud API has a limited set of possible configs of value to our sorting patterns), UI code (we gravitate towards a limited set of UX it seems), to solve much of our daily programming work.<p>ML can’t invent future ideas, it can’t evolve itself without us making new hardware for it. But it will implode the blue collar dev job market eventually.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=dragonwriter" target="_blank">dragonwriter</a>   <span class="timeago" data-date="2021-08-18 04:01:32 &#43;0000 UTC">2021-08-18 04:01:32 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; But it will implode the blue collar dev job market eventually.<p>There is no “blue collar dev job market”, and the end of the dev kob market that has a hint of a bluish tinge in the collar is the end that is <i>continuously</i> being  by tooling progress. But that just expands the scope to which it is useful to apply software development, increasing jobs and wages in software.<p>&gt; ML will (eventually) be able to generate biz logic code, and most assuredly infrastructure config (a cloud API has a limited set of possible configs of value to our sorting patterns), UI code (we gravitate towards a limited set of UX it seems), to solve much of our daily programming work.<p>Its not “machine learning”, but we already have tools that develop code in all of those domains from higher-level descriptions that what previous generations of coders supplied to them. And each generation of that tooling just serves as a progressively greater output multiplier on time devoted to developing software.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=Zababa" target="_blank">Zababa</a>   <span class="timeago" data-date="2021-08-18 03:53:02 &#43;0000 UTC">2021-08-18 03:53:02 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; ML can’t invent future ideas, it can’t evolve itself without us making new hardware for it. But it will implode the blue collar dev job market eventually.<p>I have doubts about that. Open source code seem to achieve a large part of the same function as ML (implement &quot;boring&quot; code for the Xth time) but it only has increased the number of blue collar devs. On the other hand, some no-code tools are opening programming to a large number of people (Excel, actions with your iPhone, things like that). Programming is one of those things that everyone would benefit from knowing, but time is limited, so anything to lower the barrier of entry will just lead to more programming. And more programming means even more programming (someone has to develop the no-code tools, the cloud infrastructure, etc).
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=platz" target="_blank">platz</a>   <span class="timeago" data-date="2021-08-17 18:08:02 &#43;0000 UTC">2021-08-17 18:08:02 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            how many years is eventually
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ausbah" target="_blank">ausbah</a>   <span class="timeago" data-date="2021-08-17 20:00:14 &#43;0000 UTC">2021-08-17 20:00:14 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            5-10 years, every year
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=tibbydudeza" target="_blank">tibbydudeza</a>   <span class="timeago" data-date="2021-08-17 23:58:01 &#43;0000 UTC">2021-08-17 23:58:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Everything just seems to be a rehash or improvement on C++.<p>I just want better tools i.e low code that non-programming people can use to express what they want a computer to do - something better than Excel.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=dd444fgdfg" target="_blank">dd444fgdfg</a>   <span class="timeago" data-date="2021-08-18 00:04:40 &#43;0000 UTC">2021-08-18 00:04:40 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I don&#x27;t think languages will really &quot;progress&quot; much, in the way that art doesn&#x27;t progress. That&#x27;s not to say it wont evolve to suite it&#x27;s environment.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=still_grokking" target="_blank">still_grokking</a>   <span class="timeago" data-date="2021-08-18 00:11:50 &#43;0000 UTC">2021-08-18 00:11:50 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Large parts of computer science are about languages.<p>There is a lot of progress. (Research needs to be novel usually).<p>Only that that progress arrives at mainstream usually 20+ years later, in very small batches. So it&#x27;s not very visible when looking only on the practically relevant things.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=scns" target="_blank">scns</a>   <span class="timeago" data-date="2021-08-18 13:25:19 &#43;0000 UTC">2021-08-18 13:25:19 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Very much this. The idea for the borrow checker is from the 80s IIRC.  Slowly approaching mainstream with Rust.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=analog31" target="_blank">analog31</a>   <span class="timeago" data-date="2021-08-17 22:42:39 &#43;0000 UTC">2021-08-17 22:42:39 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I would consider microcontrollers and programmable logic. They outnumber &quot;real&quot; computers and completely reshaped electronics.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=jakeogh" target="_blank">jakeogh</a>   <span class="timeago" data-date="2021-08-19 04:50:35 &#43;0000 UTC">2021-08-19 04:50:35 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            comptime fixed macros in a practical implementation: <a href="https:&#x2F;&#x2F;andrewkelley.me&#x2F;post&#x2F;zig-programming-language-blurs-line-compile-time-run-time.html" rel="nofollow">https:&#x2F;&#x2F;andrewkelley.me&#x2F;post&#x2F;zig-programming-language-blurs-...</a>
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=AtlasBarfed" target="_blank">AtlasBarfed</a>   <span class="timeago" data-date="2021-08-18 00:19:05 &#43;0000 UTC">2021-08-18 00:19:05 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            SSDs<p>Breakthroughs imply practical considerations, and SSDs were the last major improvement to hardware that also required software changes.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=rurban" target="_blank">rurban</a>   <span class="timeago" data-date="2021-08-17 19:55:43 &#43;0000 UTC">2021-08-17 19:55:43 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            SAT solvers applied.<p>You can now solve unsolvable problems, like practical formal verification in big C&#x2F;C++ codebases. There&#x27;s no need anymore to write test cases, as formal verification tries all possible input values, not just a few selected. It also checks all possible error cases, not just the ones you thought about.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=AnimalMuppet" target="_blank">AnimalMuppet</a>   <span class="timeago" data-date="2021-08-17 20:12:45 &#43;0000 UTC">2021-08-17 20:12:45 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Could you expand on what you mean by this?  Because it sounds like a level of hype bordering on nonsense.<p>1.  How is a SAT solver going to do formal verification?  How do you turn a formal verification into a SAT problem?<p>2.  You can only formally verify what your formal verifier can handle, which is usually somewhat less than &quot;everything&quot;.  Can your SAT-driven formal verifier verify that the worst case response time of the system is less than X?<p>3.  Formal verification tends to be slow.  If I can write and run unit tests orders of magnitude faster than the formal verifier, then the formal verifier is going to not be used much.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=rurban" target="_blank">rurban</a>   <span class="timeago" data-date="2021-08-18 02:38:10 &#43;0000 UTC">2021-08-18 02:38:10 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Lookup what CBMC does.<p>SAT solvers will also be also be applied in traditional compilers soon.<p>The remaining problem with formal verification and compilation is proof of termination, which is not a SAT problem.<p>Running all test cases via cbcm is magnitudes faster than writing 100% coverage (only line cov, not covered values) tests. It&#x27;s like one day vs one month. And I&#x27;ve never seen code with full value test coverage.<p>For guaranteed timing you need special tests, not a SAT solvers. The solver just helps with the proofs.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=AnimalMuppet" target="_blank">AnimalMuppet</a>   <span class="timeago" data-date="2021-08-18 16:13:27 &#43;0000 UTC">2021-08-18 16:13:27 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Even if everything you say is true, it&#x27;s true the first time.  Then I make a change to the code.  Now if I have unit tests, I have to fix a test (maybe minutes, maybe an hour) and re-run the tests (minutes).  Or I have to re-run the formal verification (a day).
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=8eye" target="_blank">8eye</a>   <span class="timeago" data-date="2021-08-18 09:16:49 &#43;0000 UTC">2021-08-18 09:16:49 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            wasm
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=beckman466" target="_blank">beckman466</a>   <span class="timeago" data-date="2021-08-17 22:46:35 &#43;0000 UTC">2021-08-17 22:46:35 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            holochains
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=pharmakom" target="_blank">pharmakom</a>   <span class="timeago" data-date="2021-08-17 16:30:56 &#43;0000 UTC">2021-08-17 16:30:56 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            IMO probably monads. Next might be Unison lang or dependent types.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=hollerith" target="_blank">hollerith</a>   <span class="timeago" data-date="2021-08-17 16:41:48 &#43;0000 UTC">2021-08-17 16:41:48 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt;&gt;What was the <i>last</i> breakthrough . . . ?<p>&gt;IMO probably monads.<p>So, you believe there have probably been no breakthroughs since 1990?
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=pharmakom" target="_blank">pharmakom</a>   <span class="timeago" data-date="2021-08-17 22:46:09 &#43;0000 UTC">2021-08-17 22:46:09 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Well it depends how you define breakthrough doesn’t it. There have absolutely been advances.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=Fire-Dragon-DoL" target="_blank">Fire-Dragon-DoL</a>   <span class="timeago" data-date="2021-08-17 17:57:00 &#43;0000 UTC">2021-08-17 17:57:00 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Isn&#x27;t Rust&#x27;s compile time memory and concurrency safety a decent breakthrough?
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=DetroitThrow" target="_blank">DetroitThrow</a>   <span class="timeago" data-date="2021-08-17 20:55:36 &#43;0000 UTC">2021-08-17 20:55:36 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I&#x27;m not sure that was a breakthrough made by Rust, but I think people agree that Rust was the first language that provided those things that people actually have wanted to use outside academia and narrow industry groups.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=scns" target="_blank">scns</a>   <span class="timeago" data-date="2021-08-18 14:18:55 &#43;0000 UTC">2021-08-18 14:18:55 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            30-40 years after being invented.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=echelon" target="_blank">echelon</a>   <span class="timeago" data-date="2021-08-17 14:56:46 &#43;0000 UTC">2021-08-17 14:56:46 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Kay is looking at a microscopic part of a vast and evolving ecosystem.<p>Take a look at deep learning, Kay. (In a sense, building models is a new type of programming, solving problems that are difficult to describe.)<p>Or maybe something a little closer to home, like Rust. It vastly improves the state of the world at the boundaries of the software layer.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=sfblah" target="_blank">sfblah</a>   <span class="timeago" data-date="2021-08-17 14:35:28 &#43;0000 UTC">2021-08-17 14:35:28 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            This is at least part of the reason that reasonably strong engineers can learn a new programming language in under a day. The paradigms just aren’t that different.<p>I realize there’s a cottage industry of folks creating new languages all the time. But when you read the docs they all bucket into a few categories, and the differences are syntax, tooling and how system services are accessed.<p>All that being said, these three categories do matter. Programming using tools like autocompletion, syntax highlighting and the like does speed productivity.<p>But, like human language, at some point the “right” set of primitives are discovered. From that point on changes become more about culture and fads than concepts.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 14:45:15 &#43;0000 UTC">2021-08-17 14:45:15 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Try learning J in a day. It...won&#x27;t go well -- but in a good way. :-) As you say, for many languages the paradigm is some variation of C, and the concepts are largely interchangeable. Then you approach something like J, where (trivial example)<p>+&#x2F;%#<p>returns the average of a list by composing three functions: + sums; % divides; # counts; with a modifier &#x2F; that distributes + throughout the list; and you begin to realize you&#x27;re not in Kansas anymore.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;J_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;J_(programming_language)</a><p>I don&#x27;t think the &quot;right&quot; set of primitives is as obvious as you say. Obviously branching and loops are foundational to <i>many</i> languages, but even those are optional given the right design, and they can be implemented in very different ways.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=derefr" target="_blank">derefr</a>   <span class="timeago" data-date="2021-08-17 15:00:00 &#43;0000 UTC">2021-08-17 15:00:00 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Definition by function&#x2F;combinator composition isn’t weird to a modern programmer (Haskell does a lot weirder); and vector processing isn’t really weird either — even Java programmers are familiar with chaining transformations and reductions on Streams these days.<p>Instead, not knowing J, the only† thing that’s weird about that J expression <i>to me</i>, is that both +&#x2F; and # are receiving the same implicit vector argument, without any Forth-like “dup” operator needing to precede them.<p>Are these operators defined to take an implicit single receiver vector? (Maybe whichever one’s on top of a “vector result stack” separate from a “scalar result stack”? Maybe the first one passed to the implicit lambda expression this code would be wrapped in?) Or is syntax sugar here hiding the argument, the way Smalltalk hides the receiver in successive expressions chained using ; ?<p>What would a compact-as-possible J expression look like, to sum up the contents of one vector, and then divide the result by the cardinality of a <i>different</i> vector?<p>—————<p>† Well, there is one other, more technical thing that’s “weird” about the expression above: it’s the fact that, unless +&#x2F; is a identifier separate from +, then the lexeme-sequence + &#x2F; has to either derive its AST by lookahead, or by + being a stack literal and &#x2F; an HOF. But then % is, seemingly, a binary infix operator. You don’t usually find both of those syntax features in the same grammar, both operating on arbitrary identifier-class lexemes, as it would usually cause an LALR parser for the language to have shift-reduce ambiguity. Unless, I suppose, the lexeme &#x2F; isn’t lexed as “an identifier” terminal, but rather its own terminal class—<i>and</i> one that’s illegal anywhere <i>but</i> postfix of an identifier.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 15:21:03 &#43;0000 UTC">2021-08-17 15:21:03 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Frankly, I suck at J. I&#x27;ve solved a few dozen project Euler problems with it, but that&#x27;s about it. If you want to see how deep the weeds get, check out this essay on solving the n-queens problem: <a href="https:&#x2F;&#x2F;code.jsoftware.com&#x2F;wiki&#x2F;Essays&#x2F;N_Queens_Problem" rel="nofollow">https:&#x2F;&#x2F;code.jsoftware.com&#x2F;wiki&#x2F;Essays&#x2F;N_Queens_Problem</a><p>J programmers just think differently.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 15:25:30 &#43;0000 UTC">2021-08-17 15:25:30 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            + is a &quot;verb&quot;
&#x2F; is an &quot;adverb&quot; -- it modifies the functionality of whatever verb it is applied to.<p>Almost all verbs can be binary or unary, sometimes with surprising (to me, a newbie) consequences. I have no idea how it gets handled underneath the hood.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=dahfizz" target="_blank">dahfizz</a>   <span class="timeago" data-date="2021-08-17 14:53:49 &#43;0000 UTC">2021-08-17 14:53:49 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            That&#x27;s just a syntax over map() and reduce(). There are no new &#x2F; different primitives in J, just a new syntax that emphasizes the use of arrays.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 15:57:59 &#43;0000 UTC">2021-08-17 15:57:59 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It&#x27;s a bit ironic that we&#x27;re essentially having a blub language debate on ycombinator&#x27;s web site. I&#x27;ll defer to Paul Graham&#x27;s response: <a href="http:&#x2F;&#x2F;www.paulgraham.com&#x2F;avg.html" rel="nofollow">http:&#x2F;&#x2F;www.paulgraham.com&#x2F;avg.html</a>
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=IncRnd" target="_blank">IncRnd</a>   <span class="timeago" data-date="2021-08-17 14:55:12 &#43;0000 UTC">2021-08-17 14:55:12 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            J is essentially APL.  I think the point is that J is functionally equivalent with many other languages, only differing in syntax but not in paradigm.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=karmakaze" target="_blank">karmakaze</a>   <span class="timeago" data-date="2021-08-17 14:57:05 &#43;0000 UTC">2021-08-17 14:57:05 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I would say that you have to think in a different style so would classify as a different paradigm and not just syntax.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=blacktriangle" target="_blank">blacktriangle</a>   <span class="timeago" data-date="2021-08-17 15:09:06 &#43;0000 UTC">2021-08-17 15:09:06 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Going back to the original comment, the statement was that any experienced engineer could learn a language in a day. At risk of gatekeeping, I&#x27;d argue that by definition any experienced engineer would have some experience with an array based language like APL or MATLAB so that no, J does not qualify as a different paradigm.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 16:12:13 &#43;0000 UTC">2021-08-17 16:12:13 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The implication of the original comment was that any C-style language engineer could learn any C-style language in a day. I&#x27;d even argue that point, but it definitely doesn&#x27;t get you J in a day, except that an supports most C-style syntax.<p>So you can program in J like a C-programmer in a day. You definitely can&#x27;t program like a J-programmer. And to say a competent engineer would already have array-language experience sidesteps the point.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=hnfong" target="_blank">hnfong</a>   <span class="timeago" data-date="2021-08-18 17:03:35 &#43;0000 UTC">2021-08-18 17:03:35 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Is Javascript a C-style language? Because even though the syntax looks superficially similar, REAL Javascript programmers apparently `npm install left-pad` instead of writing their own.<p>The C programmer in me feels abhorrent.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=IncRnd" target="_blank">IncRnd</a>   <span class="timeago" data-date="2021-08-17 16:28:42 &#43;0000 UTC">2021-08-17 16:28:42 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The original comment said nothing about C-style languages.  That must be something you read into their comment.<p>Learning J is like learning Perl or regular expressions.  Nobody really wants to engage in such an activity, but people do what they need to do.  Depending on their level of experience, a person who understands imperative and declarative paradigms along with the language&#x27;s execution model can absolutely learn J within a day, because it only differs in syntax from the existing languages.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 17:22:53 &#43;0000 UTC">2021-08-17 17:22:53 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &quot;This is at least part of the reason that reasonably strong engineers can learn a new programming language in under a day. The paradigms just aren’t that different.&quot;<p>This literally says &quot;the paradigms aren&#x27;t that different.&quot; So if you accept that C and J are different paradigms, then because the paradigms aren&#x27;t that different, a C programmer could pick up J in a day.<p>What it doesn&#x27;t say is that truly different paradigms take more than a day to learn competent programmers already understand all different paradigms.<p>Perl is C-like. As I said elsewhere, J supports C-style syntax, so sure you can program J in C-style in a day. But that&#x27;s not J. This is J:<p>for. }.z do.
  b=. -. (i.n) e.&quot;1 ,. z +&quot;1 _ ((-i.){:$z) *&#x2F; _1 0 1
  z=. ((+&#x2F;&quot;1 b)#z),.n|I.,b
end.<p>To a J programmer, that&#x27;s not just clear, it&#x27;s obvious. I&#x27;d like to meet the C-programmer who can learn to write and read that in a day.<p>And also as I responded elsewhere, this is a blub language discussion: <a href="http:&#x2F;&#x2F;www.paulgraham.com&#x2F;avg.html" rel="nofollow">http:&#x2F;&#x2F;www.paulgraham.com&#x2F;avg.html</a>
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=IncRnd" target="_blank">IncRnd</a>   <span class="timeago" data-date="2021-08-17 18:59:39 &#43;0000 UTC">2021-08-17 18:59:39 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            You are the only person who is talking about C.  It is a leap to go from &quot;experienced programmer&quot; to &quot;that means C-only programmer&quot;.  You are using the term &quot;programming paradigm&quot; incorrectly.  C is not a programming paradigm.  The paradigm of C is that it is an imperative procedural language.  In the strictest sense it is a functional language, since functions are first class citizens, but it is not really a functional language as used in practice, such as when discussing function application.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 19:30:43 &#43;0000 UTC">2021-08-17 19:30:43 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I&#x27;m using &quot;C-style language&quot; as a metaphor for &quot;imperative procedural language&quot;. I&#x27;m not the first to do so.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=IncRnd" target="_blank">IncRnd</a>   <span class="timeago" data-date="2021-08-17 20:09:27 &#43;0000 UTC">2021-08-17 20:09:27 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Clearly, C is not a functional, array language.  Nobody said it is.  What is your point?
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-18 01:47:20 &#43;0000 UTC">2021-08-18 01:47:20 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            And I didn&#x27;t say C is a functional, array language either, so we&#x27;re agreed on that. I&#x27;m lost about what your objection is at this point, so I&#x27;m happy to drop this.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=IncRnd" target="_blank">IncRnd</a>   <span class="timeago" data-date="2021-08-18 04:24:06 &#43;0000 UTC">2021-08-18 04:24:06 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Have a great day!
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=TchoBeer" target="_blank">TchoBeer</a>   <span class="timeago" data-date="2021-08-18 01:00:19 &#43;0000 UTC">2021-08-18 01:00:19 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt;To a J programmer, that&#x27;s not just clear, it&#x27;s obvious.<p>Is the argument that J just has really weird syntax? It feels trivial to me to make a mess of syntax that makes learning a language obtuse, unless there&#x27;s something more fundamentally different about J, this is the first I&#x27;m hearing of it.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-18 01:43:03 &#43;0000 UTC">2021-08-18 01:43:03 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Their argument would be that J works differently, and once you internalize how it works, many hard problems become tractable. Their slogan is something like, &quot;understand the problem, and it&#x27;s done&quot; -- meaning that once you understand the problem, the second step of translating the solution into code is near-trivial.<p>I would argue that&#x27;s at least partially because J programmers are in general incredibly smart. (I don&#x27;t count myself as a J programmer.)
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=goatlover" target="_blank">goatlover</a>   <span class="timeago" data-date="2021-08-17 15:54:54 &#43;0000 UTC">2021-08-17 15:54:54 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I guess it depends on how much past experience they had with an array-based, stack-based, logic-based, pure functional or lisp family language, and how long ago that was. I can believe an experienced engineer can learn the basics of any language in a day. But being proficient and idiomatic is another matter.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=gcanyon" target="_blank">gcanyon</a>   <span class="timeago" data-date="2021-08-17 16:05:23 &#43;0000 UTC">2021-08-17 16:05:23 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            J is functionally equivalent with APL, and a few other related languages like K. In the end you can call anything &quot;syntax,&quot; but I&#x27;d invite you to give it a try. If C is British English and Python is online-English, then J is Russian, or maybe even Mandarin.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=raxxorrax" target="_blank">raxxorrax</a>   <span class="timeago" data-date="2021-08-17 14:53:11 &#43;0000 UTC">2021-08-17 14:53:11 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            ÅF - Fibonacci in 05AB1E that are less than the current number on the stack - Good tip for when you get THAT code interview and can pick the language. Just need to know the code for Å if you are not from Denmark.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=karmakaze" target="_blank">karmakaze</a>   <span class="timeago" data-date="2021-08-17 14:55:44 &#43;0000 UTC">2021-08-17 14:55:44 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            But even this is an example of finding &#x27;a&#x27; (not &#x27;the&#x27;) right set of primitives as APL is from 1966.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=raxxorrax" target="_blank">raxxorrax</a>   <span class="timeago" data-date="2021-08-17 14:47:04 &#43;0000 UTC">2021-08-17 14:47:04 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            But you don&#x27;t know common compiler&#x2F;interpreter pitfalls, tooling, frameworks... so in the end you still need a long time to get familiar with it for productive work.<p>Sure, you know the vocabulary, but it will still take time to learn the rest.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
    
</article>

    </main>
    <footer>
        <span class="h-logo">&copy; Hugo Hacker News</span><br/>
        Site created By <a href="https://davidejones.com" target="_blank">David E Jones</a> Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> and the <a href="https://github.com/HackerNews/API" target="_blank">Hacker News api</a>.
        <ul>
            
                <li><a href="/hugo-hn/guidelines/">Guidelines</a></li>
            
                <li><a href="/hugo-hn/faq/">FAQ</a></li>
            
                <li><a href="mailto:hn@ycombinator.com">Support</a></li>
            
                <li><a href="https://github.com/HackerNews/API">API</a></li>
            
                <li><a href="/hugo-hn/security/">Security</a></li>
            
                <li><a href="/hugo-hn/lists/">Lists</a></li>
            
                <li><a href="https://news.ycombinator.com/bookmarklet.html">Bookmarklet</a></li>
            
                <li><a href="/hugo-hn/dmca/">DMCA</a></li>
            
                <li><a href="http://www.ycombinator.com/apply/">Apply to YC</a></li>
            
                <li><a href="mailto:hn@ycombinator.com">Contact</a></li>
            
        </ul>
    </footer>

    
    
    
    
    
    
    <script type="text/javascript" src="https://davidejones.github.io/hugo-hn/main.01d140732eee0e8adfdb7a7f714755097c6676bfb8e8bf27645ce342b2ed12a481b08f6838c413c20bff3acf20f6159b3336339a220ff5ec5e45eb7877106361.js"  integrity="sha512-AdFAcy7uDorf23p/cUdVCXxmdr&#43;46L8nZFzjQrLtEqSBsI9oOMQTwgv/Os8g9hWbMzYzmiIP9exeRet4dxBjYQ=="  crossorigin="anonymous" defer></script>
</body>
</html>

