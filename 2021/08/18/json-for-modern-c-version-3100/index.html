<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.87.0" />



<link rel="canonical" href="https://davidejones.github.io/hugo-hn/2021/08/18/json-for-modern-c-version-3100/">


    <title>JSON for Modern C&#43;&#43; version 3.10.0 - Hugo Hacker News</title>
    
<meta name="description" content="">

<meta property="og:title" content="JSON for Modern C&#43;&#43; version 3.10.0 - Hugo Hacker News">
<meta property="og:type" content="article">
<meta property="og:url" content="https://davidejones.github.io/hugo-hn/2021/08/18/json-for-modern-c-version-3100/">
<meta property="og:image" content="https://davidejones.github.io/hugo-hn/images/default.png">
<meta property="og:site_name" content="Hugo Hacker News">
<meta property="og:description" content="">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="Hugo Hacker News">
<meta name="twitter:url" content="https://davidejones.github.io/hugo-hn/2021/08/18/json-for-modern-c-version-3100/">
<meta name="twitter:title" content="JSON for Modern C&#43;&#43; version 3.10.0 - Hugo Hacker News">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://davidejones.github.io/hugo-hn/images/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"https:\/\/davidejones.github.io\/hugo-hn\/"
    },
    "headline": "JSON for Modern C\u002b\u002b version 3.10.0 - Hugo Hacker News",
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/davidejones.github.io\/hugo-hn\/images\/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2021-08-18T06:00:52JST",
    "dateModified": "2021-08-18T06:00:52JST",
    "author": {
      "@type": "Person",
      "name": "Hugo Hacker News"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Hugo Hacker News",
      "logo": {
        "@type": "ImageObject",
        "url": "https:\/\/davidejones.github.io\/hugo-hn\/images/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": ""
  }
</script>



    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">

    
    
    
    
        
    
    
    <link href="https://davidejones.github.io/hugo-hn/style.min.130df59cea3bafd8a515eeb4a51c215616cb41f2a9520765b9f1574d3cfedf2c485abb4a8d785adcd7acdc2400797ba6abffe5b0bb4612cb79bc0b884aac89e8.css" rel="stylesheet" />
</head>
<body class="post">
    <header>
        <a href="https://davidejones.github.io/hugo-hn/">Hugo Hacker News</a>
        <nav>
            <ul>
                
                    <li><a href="/hugo-hn/">new</a></li>
                
                    <li><a href="/hugo-hn/comments/">comments</a></li>
                
                    <li><a href="/hugo-hn/categories/show/">show</a></li>
                
                    <li><a href="/hugo-hn/categories/ask/">ask</a></li>
                
                    <li><a href="/hugo-hn/categories/jobs/">jobs</a></li>
                
                    <li><a href="https://news.ycombinator.com/submit">submit</a></li>
                
            </ul>
        </nav>
        <select onchange="myChangeHandler(this)">
            
                <option value="/hugo-hn/">new</option>
            
                <option value="/hugo-hn/comments/">comments</option>
            
                <option value="/hugo-hn/categories/show/">show</option>
            
                <option value="/hugo-hn/categories/ask/">ask</option>
            
                <option value="/hugo-hn/categories/jobs/">jobs</option>
            
                <option value="https://news.ycombinator.com/submit">submit</option>
            
        </select>
    </header>
    <main>
        
<article>
    <header>
        <h1><a href="https://github.com/nlohmann/json/releases/tag/v3.10.0">JSON for Modern C&#43;&#43; version 3.10.0</a></h1>
        
    </header>
    
        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=lazypenguin" target="_blank">lazypenguin</a>   <span class="timeago" data-date="2021-08-19 12:20:04 &#43;0000 UTC">2021-08-19 12:20:04 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The comments here are uncharitable. For some reason when someone posts a C++ project all the nitpickers come out of the woodwork. Is it as fast as simdjson? No but simdjson is read only. Is it as memory efficient as rapidjson sax writer? No, but it’s a hell of a lot more ergonomic. Is it “modern” C++? Yes it is, just open the source and you can see you for yourself. Nitpicking which standard is allowed to be call modern is silly. I’d argue modern C++ is a style or way of thinking. Would I use it for all projects? Maybe not but this is a good, high quality library.<p>Dear @nlohmann and contributors. Thank you for this library, I’ve used it in the past and appreciate your work and efforts.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=nikki93" target="_blank">nikki93</a>   <span class="timeago" data-date="2021-08-19 05:06:54 &#43;0000 UTC">2021-08-19 05:06:54 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The API side of this library is pretty good. I&#x27;ve generally avoided it due to the compile time, and preferred rapidjson due to both better performance and compile time if I wanted a C++ API, or cJSON if a C API is fine and I really just want an extremely low compile time (lately I&#x27;ve been playing with a live coding C++ context for a game engine, as a side project, I use cJSON there; rapidjson on main project though) (cJSON&#x27;s tradeoff is it sticks with a single global allocator that you can only customize in one location, and also seems to perf slightly lower on parse).<p>The cJSON&#x27;s C API or rapidjson&#x27;s somewhat less ergonomic API has felt fine because I usually have read &#x2F; write be reflective and don&#x27;t write that much manual JSON code.<p>Specifically for the case where compile time doesn&#x27;t matter and I need expressive JSON object mutation in C++ (or some tradeoff thereof), I think this library seems good.<p>Another big feature (which I feel like it could be louder about -- it really is a big one!) is that you can also generate binary data in a bunch of formats (BSON, CBOR, MessagePack and UJBJSON) that have a node structure similar to JSON&#x27;s -- from the same in-memory instances of this library&#x27;s data type. That sort of thing is something I&#x27;ve desired for various reasons (smaller file types with potentially better network send time for asynchronous sending &#x2F; downloads (for real-time multiplayer you still basically want to encode to something that doesn&#x27;t embed field string names)). I do think I may end up doing it at one layer above in the engine level and just have a different backend other than cJSON etc. too though...
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=qalmakka" target="_blank">qalmakka</a>   <span class="timeago" data-date="2021-08-19 09:11:14 &#43;0000 UTC">2021-08-19 09:11:14 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            While I agree on you on compile times getting slower with nlohmann&#x2F;json, I think that its performances are fairly adequate. I&#x27;ve been using it on the ESP32 in single core mode and it&#x27;s still fast enough for everything. Unless you parse tens of millions of JSON objects per second, you won&#x27;t really notice any difference between the various JSON libraries.<p>Ironically, cJSON is _worse_ in my use case due to it not supporting allocators at all, as you wrote. Nlohmann fully supports C++ allocators, so it&#x27;s trivial to allocate on SPIRAM instead of the limited DRAM of the ESP32. Support for allocators is why I often tend to pick C++ for projects with heterogeneous kinds of memory.<p>Also, Nlohmann&#x2F;JSON supports strong typed serialization and deserialization, which in my experience vastly reduces the amount of errors people tend to make when reading&#x2F;writing data to JSON. I&#x27;ve found simpler to rewrite some critical code that was parsing very complex data using cJSON to Nlohmann&#x2F;JSON than fixing up all the tiny errors the previous developer made while reading &quot;raw&quot; JSON, parsing numbers as enums, strings as other kinds of enums, and so on.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=cibomahto" target="_blank">cibomahto</a>   <span class="timeago" data-date="2021-08-19 12:17:49 &#43;0000 UTC">2021-08-19 12:17:49 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            For what it&#x27;s worth, cJSON does support a (global) allocator override, using cJSON_InitHooks().<p>Here&#x27;s what I use on ESP32 to push allocation to SPIRAM: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;cibomahto&#x2F;a29b6662847e13c61b47a194fad4ab11" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;cibomahto&#x2F;a29b6662847e13c61b47a194fa...</a>
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=nlohmann" target="_blank">nlohmann</a>   <span class="timeago" data-date="2021-08-19 11:57:57 &#43;0000 UTC">2021-08-19 11:57:57 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Great to hear that you made good experiences with user-defined allocators. It would be great if you could provide a pointer to an example, because we always fall short in testing the allocator usage. So if you had a small example, you could really improve the status quo :)
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=ephaeton" target="_blank">ephaeton</a>   <span class="timeago" data-date="2021-08-19 05:19:52 &#43;0000 UTC">2021-08-19 05:19:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Plusses: as a user of nlohmann-json, I also like the support for json pointer, json patch and json merge patch which comes in handy at times. I like their way of handling to&#x2F;from_json (declare functions with appropriate signature and namespacing and the lib will pick them up seamlessly in implicit conversions). &quot;standard&quot; container facades are appreciated.<p>Minusses: although I&#x27;d like a way to append a (C-)array into a JSON-array &quot;at once&quot; and not iteratively (i.e., O(n) instead of O(n log n)). Also, lack of support for JSON schema is .. slightly annoying.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=nlohmann" target="_blank">nlohmann</a>   <span class="timeago" data-date="2021-08-19 11:56:23 &#43;0000 UTC">2021-08-19 11:56:23 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Can you elaborate on your minuses - I don&#x27;t understand what you mean with &quot;at once&quot; in that context.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=AlexandrB" target="_blank">AlexandrB</a>   <span class="timeago" data-date="2021-08-19 12:26:30 &#43;0000 UTC">2021-08-19 12:26:30 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            For JSON schema, I&#x27;ve found that this third party library works well: <a href="https:&#x2F;&#x2F;github.com&#x2F;pboettch&#x2F;json-schema-validator" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;pboettch&#x2F;json-schema-validator</a>
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=nikki93" target="_blank">nikki93</a>   <span class="timeago" data-date="2021-08-19 05:25:16 &#43;0000 UTC">2021-08-19 05:25:16 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Yeah the support for pointer &#x2F; patch etc. is a definite plus. The customization point thing I tend to do with my own customization points, but it&#x27;s pretty good if a bunch of libraries settle on a standard customization point (eg. I think serde in Rust has achieved that a bit due to the ecosystem there) (definitely want it to be static).<p>I didn&#x27;t realize that about the array complexity. Can you not just initialize a JSON array of N elements in O(N) (conceding a `.reserve(N)` style call beforehand if required)? rapidjson is pretty good about that sort of thing, cJSON&#x27;s arrays are linked list so I basically think of its performance as at a different level and it&#x27;s mostly about compile time for me.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=ephaeton" target="_blank">ephaeton</a>   <span class="timeago" data-date="2021-08-19 05:37:36 &#43;0000 UTC">2021-08-19 05:37:36 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I haven&#x27;t found a way to do that. The only O(n) to-json-array way is using the initializer list constructor AFAICT.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=" target="_blank"></a>   <span class="timeago" data-date="2021-08-19 12:39:01 &#43;0000 UTC">2021-08-19 12:39:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=esprehn" target="_blank">esprehn</a>   <span class="timeago" data-date="2021-08-19 03:49:46 &#43;0000 UTC">2021-08-19 03:49:46 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            This doesn&#x27;t appear to be all that &quot;modern&quot;: it doesn&#x27;t support string_view for lookup without extra allocations, and it doesn&#x27;t support unordered_map (or even use it as the default) for objects.<p>It seems they&#x27;re targeting C++11?
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=nlohmann" target="_blank">nlohmann</a>   <span class="timeago" data-date="2021-08-19 12:01:59 &#43;0000 UTC">2021-08-19 12:01:59 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The development started in 2013 when C++11 was still modern. Since then, the term &quot;modern C++&quot; is, to my understanding, a synonym for &quot;C++11 and later&quot;. Of course, some code may look dated compared to newer C++ constructs, but the main goal is to integrate JSON into any C++ code bases without making it look odd.<p>The string_view lookup is nearly done, but I did not want to wait for it, because it would have delayed the release even more.<p>I&#x27;m also working on supporting unordered_map - using it as container for objects would be easy if we would just break the existing API - the hard part is to support it with the current (probably bad designed) template API.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=MauranKilom" target="_blank">MauranKilom</a>   <span class="timeago" data-date="2021-08-19 08:11:12 &#43;0000 UTC">2021-08-19 08:11:12 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; and it doesn&#x27;t support unordered_map (or even use it as the default) for objects.<p>std::unordered_map has massive overhead in space and time. Maybe I misunderstand your idea, but outside of <i>extremely</i> niche use cases, std::unordered_map is basically never the right tool (unless you don&#x27;t care in the slightest about performance or memory overhead).
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=agent327" target="_blank">agent327</a>   <span class="timeago" data-date="2021-08-19 08:36:08 &#43;0000 UTC">2021-08-19 08:36:08 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Source? A hash map should in principle be faster than a tree, with far fewer comparisons, and against a computed hash value instead of the whole object, in principle.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=einpoklum" target="_blank">einpoklum</a>   <span class="timeago" data-date="2021-08-19 10:57:01 &#43;0000 UTC">2021-08-19 10:57:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Well, std::unordered_map is faster than than std::map, but it is still slow, since it uses lists for its buckets, with lots of dynamic allocation. See also:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;42588384&#x2F;1593077" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;42588384&#x2F;1593077</a><p>and the link there. Not sure that&#x27;s what GP meant though.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=agent327" target="_blank">agent327</a>   <span class="timeago" data-date="2021-08-19 13:15:01 &#43;0000 UTC">2021-08-19 13:15:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I don&#x27;t believe it has to, some kind of bucket-optimisation (multiple elements per allocation, instead of one element per allocation) should also meet all constraints the standard sets for this type.<p>And I don&#x27;t like it when people use ridiculous hyperbole to describe what is in reality barely perceptible overhead, so it would be good if the person I originally responded to came out and defended his POV. Hopefully using actual numbers instead of agitated handwaving and screaming...
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=MauranKilom" target="_blank">MauranKilom</a>   <span class="timeago" data-date="2021-08-19 16:06:10 &#43;0000 UTC">2021-08-19 16:06:10 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; some kind of bucket-optimisation (multiple elements per allocation, instead of one element per allocation) should also meet all constraints the standard sets for this type<p>Pretty sure that makes it impossible to implement merge without pointer&#x2F;iterator invalidation, which is a constraint imposed by the standard (<a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;container&#x2F;unordered_map&#x2F;merge" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;container&#x2F;unordered_map&#x2F;me...</a>).<p>&gt;  it would be good if the person I originally responded to came out and defended his POV<p>See <a href="https:&#x2F;&#x2F;probablydance.com&#x2F;2017&#x2F;02&#x2F;26&#x2F;i-wrote-the-fastest-hashtable&#x2F;" rel="nofollow">https:&#x2F;&#x2F;probablydance.com&#x2F;2017&#x2F;02&#x2F;26&#x2F;i-wrote-the-fastest-has...</a> if you want numbers, or for example this talk by the same author <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=M2fKMP47slQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=M2fKMP47slQ</a>.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=beached_whale" target="_blank">beached_whale</a>   <span class="timeago" data-date="2021-08-19 15:49:05 &#43;0000 UTC">2021-08-19 15:49:05 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Abseil has a btree based hash map and it performs much better.  I think it maintains the same constrains(iterator invalidation&#x2F;exception safety...) as std::unordered_map.<p>The issue is that the implementors won&#x27;t change their implementation of unordered_map as it&#x27;s an ABI break, to say it simply.  It could be better.  But also, there are other tools like flat maps&#x2F;open addressing that are not done in the std library.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=wmkn" target="_blank">wmkn</a>   <span class="timeago" data-date="2021-08-19 12:41:56 &#43;0000 UTC">2021-08-19 12:41:56 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            What? I would argue that unordered_map is nearly always a reasonable choice when in need of an unordered associative container. There is nothing particular wrong with it.<p>Not sure what your rationale is for saying it’s only useful for extremely niche use cases. I would be curious to know why you think so.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=MauranKilom" target="_blank">MauranKilom</a>   <span class="timeago" data-date="2021-08-19 16:17:19 &#43;0000 UTC">2021-08-19 16:17:19 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It has the right asymptotic guarantees for a hash map, but beyond that it doesn&#x27;t have much going for it. The degree to which it emphasizes pointer&#x2F;iterator stability and arbitrary load factors is not a good tradeoff in almost any practical case (unless you do not care about performance).<p>See <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=M2fKMP47slQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=M2fKMP47slQ</a> for a more comprehensive discussion, or the sibling threads here.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=spacechild1" target="_blank">spacechild1</a>   <span class="timeago" data-date="2021-08-19 10:29:57 &#43;0000 UTC">2021-08-19 10:29:57 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; but outside of extremely niche use cases, std::unordered_map is basically never the right tool<p>std::map is only useful if you need the data to be ordered, otherwise std::unordered_map is the right default choice.<p>&gt; std::unordered_map has massive overhead in space and time.<p>Yes, std::unordered_map uses a bit more memory, but please show me some benchmarks where it is slower than std::map - especially with string keys!<p>BTW, for very small numbers of items the most efficient solution is often a plain std::vector + linear search.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=MauranKilom" target="_blank">MauranKilom</a>   <span class="timeago" data-date="2021-08-19 16:14:07 &#43;0000 UTC">2021-08-19 16:14:07 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I didn&#x27;t meant to imply it will perform worse than std::map. My point is that std::unordered_map has very particular design tradeoffs (primarily the requirement for arbitrary load factors and the bucket interface) that fundamentally impose large space and time overhead: Every node has to be stored as separately allocated linked list entry.<p>That&#x27;s sometimes ok, particularly if you don&#x27;t care about performance (beyond asymptotic behavior). But if you do, you&#x27;d probably be well-advised to try out hash map implementations that actually don&#x27;t leave performance on the table by design.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=adzm" target="_blank">adzm</a>   <span class="timeago" data-date="2021-08-19 12:08:14 &#43;0000 UTC">2021-08-19 12:08:14 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; BTW, for very small numbers of items the most efficient solution is often a plain std::vector + linear search.<p>This is why flat_map is a great solution. It&#x27;s basically an ordered vector with a map-like interface, but without the memory allocation (and cache locality issues) for each node. Until you start getting into thousands of elements it is probably the best choice of container.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=codr7" target="_blank">codr7</a>   <span class="timeago" data-date="2021-08-19 11:40:19 &#43;0000 UTC">2021-08-19 11:40:19 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It&#x27;s a gradient, from the vector you mentioned all the way up to hash maps.<p>And ordered maps fall somewhere in the middle.<p>They might make sense if you&#x27;re creating massive amounts of medium sized maps.<p>Or if you need range searches etc.<p>It&#x27;s all compromises, there are no hard rules.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=batty_alex" target="_blank">batty_alex</a>   <span class="timeago" data-date="2021-08-19 11:44:45 &#43;0000 UTC">2021-08-19 11:44:45 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I think you might have it backwards. std::map is the one you only want to reach for in cases where you need a sorted dictionary (it sorts after insert)<p>std::unordered_map is typically the go-to hash map on any given C++ day. You’re probably fine with std::map outside of large n<p>EDIT: being pedantic
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=adzm" target="_blank">adzm</a>   <span class="timeago" data-date="2021-08-19 12:03:12 &#43;0000 UTC">2021-08-19 12:03:12 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            You can provide alternative collections if needed by templating basic_json; std::map is just a default. Personally I like using a flat_map which is an ordered map built on top of a vector, which provides nice cache locality and is generally even faster than a hash map &#x2F; unordered_map except for extremely large objects.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=beached_whale" target="_blank">beached_whale</a>   <span class="timeago" data-date="2021-08-19 04:25:42 &#43;0000 UTC">2021-08-19 04:25:42 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The C++11 is still common enough that if you want a large usage group it&#x27;s the target.  However, it&#x27;s parsing to a DOM and doesn&#x27;t use features like PMR, so the language features needed won&#x27;t be more than std containers and stuff.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=quietbritishjim" target="_blank">quietbritishjim</a>   <span class="timeago" data-date="2021-08-19 10:58:57 &#43;0000 UTC">2021-08-19 10:58:57 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I think it makes sense to target C++11. Just that you shouldn&#x27;t then call the library &quot;modern&quot;.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=nlohmann" target="_blank">nlohmann</a>   <span class="timeago" data-date="2021-08-19 12:03:30 &#43;0000 UTC">2021-08-19 12:03:30 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            There is also a SAX parser.<p>But to be honest, I have not yet played around with PMR.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=beached_whale" target="_blank">beached_whale</a>   <span class="timeago" data-date="2021-08-19 12:50:25 &#43;0000 UTC">2021-08-19 12:50:25 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I know when I was benching JSON Link, I saw 30-50% increase in perf at the time when using better allocators and PMR can help a lot there with things like bump allocators.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=pjmlp" target="_blank">pjmlp</a>   <span class="timeago" data-date="2021-08-19 05:13:42 &#43;0000 UTC">2021-08-19 05:13:42 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Specially among the C+ community groups.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=beached_whale" target="_blank">beached_whale</a>   <span class="timeago" data-date="2021-08-19 05:34:40 &#43;0000 UTC">2021-08-19 05:34:40 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It is changing and I saw some survey’s showing 17 around 1&#x2F;2 the shops.  I know for my JSON library it wouldn’t be possible without C++ 17 so it’s a loss of eyes
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=pjmlp" target="_blank">pjmlp</a>   <span class="timeago" data-date="2021-08-19 05:38:52 &#43;0000 UTC">2021-08-19 05:38:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Yeah, thing is how much C++17 is actually used beyond the language version.<p>For example, C++&#x2F;WinRT is a C++17 library, yet plenty of samples use C style strings and vectors.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=howolduis" target="_blank">howolduis</a>   <span class="timeago" data-date="2021-08-19 04:17:29 &#43;0000 UTC">2021-08-19 04:17:29 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            people love to complain
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=rualca" target="_blank">rualca</a>   <span class="timeago" data-date="2021-08-19 05:51:07 &#43;0000 UTC">2021-08-19 05:51:07 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; people love to complain<p>Do you find it unreasonable to point out that what&#x27;s been advertised doesn&#x27;t match what&#x27;s being offered?
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=nlohmann" target="_blank">nlohmann</a>   <span class="timeago" data-date="2021-08-19 12:04:27 &#43;0000 UTC">2021-08-19 12:04:27 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            As I tried to describe earlier: &quot;modern C++&quot; is not necessarily &quot;using the latest standard&quot;, but rather &quot;C++ since it was updated with C++11 (and later)&quot;.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=rualca" target="_blank">rualca</a>   <span class="timeago" data-date="2021-08-19 12:08:42 &#43;0000 UTC">2021-08-19 12:08:42 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Aiming at C++11 is not a reasonable definition of &quot;modern&quot;, as it was C++&#x27;s second ISO standard that was published a decade ago and which has since seen between two and three major updates (depending on the opinions on c++14)
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=nlohmann" target="_blank">nlohmann</a>   <span class="timeago" data-date="2021-08-19 12:13:01 &#43;0000 UTC">2021-08-19 12:13:01 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It&#x27;s not the &quot;aiming at C++11&quot;, but rather &quot;Write code that does not look odd in a code base that is using constructs from C++11, C++14, C++17, etc.&quot; - The library uses C++11 to implement an API that should not feel weird when used together with other containers from the STL.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=maleldil" target="_blank">maleldil</a>   <span class="timeago" data-date="2021-08-19 12:22:52 &#43;0000 UTC">2021-08-19 12:22:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            C++11 was a huge shift in how C++ is written, and term coined for &quot;code written using the new techniques&quot; was &quot;Modern C++&quot;. Whether you think that term should instead mean &quot;the latest C++ version&quot; is a different matter altogether.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=bobnamob" target="_blank">bobnamob</a>   <span class="timeago" data-date="2021-08-19 12:21:10 &#43;0000 UTC">2021-08-19 12:21:10 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            In C++ land &quot;modern&quot; has become synonymous with post 11. Effectively a domain specific definition. Reasonable considering the difference between pre and post 11. Pre and post 20 will probably be treated similarly in a decade
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=q-rews" target="_blank">q-rews</a>   <span class="timeago" data-date="2021-08-19 05:18:47 &#43;0000 UTC">2021-08-19 05:18:47 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            People love correct statements. C++11 was release 10 years ago and there are 3 newer versions.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=pjmlp" target="_blank">pjmlp</a>   <span class="timeago" data-date="2021-08-19 05:12:55 &#43;0000 UTC">2021-08-19 05:12:55 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            For many even using RAII, which even Turbo Vision for MS-DOS made use of, is already &quot;modern&quot;.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=mike_hock" target="_blank">mike_hock</a>   <span class="timeago" data-date="2021-08-19 08:29:45 &#43;0000 UTC">2021-08-19 08:29:45 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It uses the ordering of std::map for its own comparison operators and hash function.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=microtherion" target="_blank">microtherion</a>   <span class="timeago" data-date="2021-08-19 13:02:23 &#43;0000 UTC">2021-08-19 13:02:23 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            An awesome library, wonderfully convenient to use. I particularly like being able to use the same code for JSON and CBOR.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=SloopJon" target="_blank">SloopJon</a>   <span class="timeago" data-date="2021-08-19 05:14:24 &#43;0000 UTC">2021-08-19 05:14:24 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            This is the library I settled on for a project a couple of years ago.  Although I was intrigued by the magic of expression templates, my usage is actually pretty straightforward and boring.  One thing it has that some of the other libraries I evaluated lack is the ability to parse numeric strings yourself, which I wanted for a decimal floating-point type.<p>There are lots of other libraries, and surely some faster ones, but I haven&#x27;t felt any need to change.  I was nervous when I got an inexplicable overload ambiguity in xlclang++ for AIX, but it went away when I grabbed a newer version of the library.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=iamvnraju" target="_blank">iamvnraju</a>   <span class="timeago" data-date="2021-08-19 05:39:53 &#43;0000 UTC">2021-08-19 05:39:53 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I remember having used nlohmann&#x27;s single header JSON parser library around 2018 on a client app and found it to be pretty nifty. For REST, I had had used Boost Beast.
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=_3u10" target="_blank">_3u10</a>   <span class="timeago" data-date="2021-08-19 04:31:29 &#43;0000 UTC">2021-08-19 04:31:29 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Cool project. Others may also be interested in simdjson which parses at about 4GB&#x2F;sec.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson&#x2F;blob&#x2F;master&#x2F;doc&#x2F;basics.md#the-basics-loading-and-parsing-json-documents" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson&#x2F;blob&#x2F;master&#x2F;doc&#x2F;basics....</a>
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=adzm" target="_blank">adzm</a>   <span class="timeago" data-date="2021-08-19 12:10:57 &#43;0000 UTC">2021-08-19 12:10:57 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            simdjson is an awesome project. However, it&#x27;s analogous to a SAX parser for XML vs a DOM model. If that is all you need (or if you are building something like a DOM yourself) then it is pretty much impossible to beat. Having an entire JSON document parsed and in memory at once though has a bunch of advantages for a friendlier API.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=joshxyz" target="_blank">joshxyz</a>   <span class="timeago" data-date="2021-08-19 08:09:14 &#43;0000 UTC">2021-08-19 08:09:14 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            yes another great one<p>these projects are just commendable!
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=modeless" target="_blank">modeless</a>   <span class="timeago" data-date="2021-08-19 06:55:29 &#43;0000 UTC">2021-08-19 06:55:29 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Huh, I was just in some code that uses this library a few days ago. I wish it included a base64 implementation for more efficiently encoding arrays of bytes or floats. JSON is inefficient for large arrays of numbers.
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=jcelerier" target="_blank">jcelerier</a>   <span class="timeago" data-date="2021-08-19 07:00:31 &#43;0000 UTC">2021-08-19 07:00:31 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Why wouldn&#x27;t you use a base64 library ? This is prime library bloat mindset. Base64 has nothing to do in a JSON lib; there are a ton of implementations out there.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=modeless" target="_blank">modeless</a>   <span class="timeago" data-date="2021-08-19 14:28:34 &#43;0000 UTC">2021-08-19 14:28:34 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            A base64 implementation is very small, but not completely trivial to the point where you should implement it yourself, or paste in a one liner from Stack Overflow. It&#x27;s widely used with JSON. C++ has no package manager to make it easy to import tiny libraries for purposes like this, so C++ libraries should be a little more self contained than npm packages or rust crates. It would absolutely be reasonable to include a base64 implementation in a C++ JSON library for those reasons.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=" target="_blank"></a>   <span class="timeago" data-date="2021-08-19 12:51:24 &#43;0000 UTC">2021-08-19 12:51:24 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=tsbinz" target="_blank">tsbinz</a>   <span class="timeago" data-date="2021-08-19 07:25:26 &#43;0000 UTC">2021-08-19 07:25:26 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Uh, it has plenty of methods for more compact encodings? <a href="https:&#x2F;&#x2F;github.com&#x2F;nlohmann&#x2F;json#binary-formats-bson-cbor-messagepack-and-ubjson" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;nlohmann&#x2F;json#binary-formats-bson-cbor-me...</a>
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=modeless" target="_blank">modeless</a>   <span class="timeago" data-date="2021-08-19 14:23:52 &#43;0000 UTC">2021-08-19 14:23:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Sure, if you want to change the format of the whole message. If you&#x27;re communicating with something that accepts JSON and you can&#x27;t or don&#x27;t want to change that, then having a more efficient option is nice.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=versatran01" target="_blank">versatran01</a>   <span class="timeago" data-date="2021-08-19 03:58:49 &#43;0000 UTC">2021-08-19 03:58:49 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I prefer boost json
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=darknavi" target="_blank">darknavi</a>   <span class="timeago" data-date="2021-08-19 05:27:59 &#43;0000 UTC">2021-08-19 05:27:59 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            How do people go about integrating boost these days? For any cross platform projects I use CMake and Boost seems like a _very_ scary library to try and build&#x2F;ship on multiple platforms.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=chrisjericho" target="_blank">chrisjericho</a>   <span class="timeago" data-date="2021-08-19 05:54:24 &#43;0000 UTC">2021-08-19 05:54:24 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I use CMake almost exclusively (even for Windows) and using &quot;find_package(Boost REQUIRED)&quot; works most of the time. A lot of common boost libraries (algorithm, geometry) are header only and are not much of a hassle to include.<p>IIRC, you would need to modify the statement to &quot;find_package(Boost REQUIRED COMPONENTS filesystem)&quot; if you want to use boost dependencies that need a separate .dll&#x2F;.so (in this case boost::filesystem). However I rarely need to use these, so I may be wrong.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=electroly" target="_blank">electroly</a>   <span class="timeago" data-date="2021-08-19 15:37:41 &#43;0000 UTC">2021-08-19 15:37:41 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            FWIW Boost.Json in particular doesn&#x27;t have any source files, it&#x27;s just header-only templates. You don&#x27;t actually need to build or link boost to use it; you just need the header files to be in the include path.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=Johnnynator" target="_blank">Johnnynator</a>   <span class="timeago" data-date="2021-08-19 05:59:34 &#43;0000 UTC">2021-08-19 05:59:34 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            You should be able to build and include boost json as a standalone subproject in CMake if you are using C++17. (Or also possible to use as header only lib)<p>It gets far more complicated with C++11, since you also need a ton of other boost modules there.<p>For more Details you can read the Readme of it. <a href="https:&#x2F;&#x2F;github.com&#x2F;boostorg&#x2F;json" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;boostorg&#x2F;json</a>
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=nly" target="_blank">nly</a>   <span class="timeago" data-date="2021-08-19 05:55:35 &#43;0000 UTC">2021-08-19 05:55:35 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            CMake supports Boost out of the box, you just need to set BOOST_ROOT to your Boost install path.<p>With proper CI it&#x27;s not a big deal
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=jcelerier" target="_blank">jcelerier</a>   <span class="timeago" data-date="2021-08-19 07:04:53 &#43;0000 UTC">2021-08-19 07:04:53 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            <p><pre><code>    wget boost_1_77.tar.gz
    tar xaf boost*
    cmake ... -DBOOST_ROOT=...&#x2F;boost_1_77
</code></pre>
Works for the huge majority of boost ; most parts that required a build were the parts that were integrated in c++ like thread, regex, chrono, filesystem
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=geokon" target="_blank">geokon</a>   <span class="timeago" data-date="2021-08-19 06:16:59 &#43;0000 UTC">2021-08-19 06:16:59 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Use Hunter for dependency management<p><a href="https:&#x2F;&#x2F;github.com&#x2F;cpp-pm&#x2F;hunter" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;cpp-pm&#x2F;hunter</a><p>There is a bit of a learning curve, but it&#x27;s the only dependency manager that does things right (all from within CMake)
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=rualca" target="_blank">rualca</a>   <span class="timeago" data-date="2021-08-19 05:56:52 &#43;0000 UTC">2021-08-19 05:56:52 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            What exactly makes Boost scary to ship? I understand that Boost requires some attention to build right across platforms (see zlib support in Windows) but other than this it&#x27;s pretty straight forward to add a FindBoost statement to your code, and move onto other things.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=beached_whale" target="_blank">beached_whale</a>   <span class="timeago" data-date="2021-08-19 04:07:26 &#43;0000 UTC">2021-08-19 04:07:26 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It does seem to have a very similar interface to this and has the performance of RapidJSON.  So a nice balance in that regard.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=newusertoday" target="_blank">newusertoday</a>   <span class="timeago" data-date="2021-08-19 06:30:29 &#43;0000 UTC">2021-08-19 06:30:29 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            off topic, is there any tool which can be used to query json file that also has autocomplete functionality for keys?
        </div>
        <div class="children">
            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=einpoklum" target="_blank">einpoklum</a>   <span class="timeago" data-date="2021-08-19 10:54:45 &#43;0000 UTC">2021-08-19 10:54:45 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            From the repository&#x27;s README:<p>&gt; Speed. There are certainly faster JSON libraries out there. However, if your goal is to speed up your development by adding JSON support with a single header, then this library is the way to go.<p>It is essentially admitting to being slow(er). We are not supposed to pay for code modernity with performance. In fact, it should be the other way around.<p>Does someone know the innards of this library as opposed to, say, jsoncpp or other popular libraries, and describe the differences?
        </div>
        <div class="children">
            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=nlohmann" target="_blank">nlohmann</a>   <span class="timeago" data-date="2021-08-19 12:07:11 &#43;0000 UTC">2021-08-19 12:07:11 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The library aims at making anything related to JSON straightforward to implement. For some applications, this is a good compromise. The comment in the README is like the answer to a FAQ &quot;How fast is it?&quot;
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=einpoklum" target="_blank">einpoklum</a>   <span class="timeago" data-date="2021-08-19 16:12:59 &#43;0000 UTC">2021-08-19 16:12:59 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; This is a good compromise<p>You&#x27;re making the false assumption that there is a compromise to be made - but there isn&#x27;t. A modern JSON library should be the fastest (or about the same speed as the fastest), and vice-versa.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=TeeMassive" target="_blank">TeeMassive</a>   <span class="timeago" data-date="2021-08-19 04:45:00 &#43;0000 UTC">2021-08-19 04:45:00 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &gt; The CSV format itself is notoriously inconsistent<p>So what? The format is so simple that the inconsistencies doesn&#x27;t even matter and hell the format can be inferred from the data and that can even be automated. Unlike JSON&#x2F;XML, most software can automatically make sense of CSV; JSON needs a developer to understand it to transform it into workable data.<p>&gt; CSVs often begin life as exported spreadsheets or table dumps from legacy databases, and often end life as a pile of undifferentiated files in a data lake, awaiting the restoration of their precious metadata so they can be organized and mined for insights.<p>CSVs are the de facto way to export spreadsheets and if you have to do this then the problem are that you are still using spreadsheets in your data flow, not CSVs. Same goes for legacy systems.<p>Also CSVs comes from places where having more sophisticated data serializers is near impossible and the time to code, compute, parse and analyze CSVs is trivial compared to any other format out there.<p>&gt; I’ve spent many years battling CSVs in various capacities. As an engineer at Trifacta, a leading data preparation tool vendor, I saw numerous customers struggling under the burden of myriad CSVs that were the product of even more numerous Excel spreadsheet exports and legacy database dumps. As an engineering leader in biotech, my team struggled to ingest CSVs from research institutions and hospital networks who gave us sample data as CSVs more often than not.<p>Of course if you are working in biotech then you&#x27;ll work with scientists (horrible coders most of the time) and legacy systems because it&#x27;s a domain that&#x27;s very adverse to change that might break stuff. And it&#x27;s not the CSV format&#x27;s fault if it&#x27;s used as the wrong tool for the job.<p>&gt; Another big drawback of CSV is its almost complete lack of metadata.<p>Again, emphasis on the right tool for the job. For simple tasks metada are not needed.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=Stratoscope" target="_blank">Stratoscope</a>   <span class="timeago" data-date="2021-08-19 04:55:00 &#43;0000 UTC">2021-08-19 04:55:00 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            You mistakenly replied on the wrong thread. Here&#x27;s the one you meant to reply on:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28221654" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28221654</a><p>Your quote &quot;The CSV format itself is notoriously inconsistent&quot; comes from this page which the thread discusses:<p><a href="https:&#x2F;&#x2F;www.bitsondisk.com&#x2F;writing&#x2F;2021&#x2F;retire-the-csv&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.bitsondisk.com&#x2F;writing&#x2F;2021&#x2F;retire-the-csv&#x2F;</a>
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
            


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=knorker" target="_blank">knorker</a>   <span class="timeago" data-date="2021-08-19 08:25:15 &#43;0000 UTC">2021-08-19 08:25:15 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            &quot;Modern&quot; C++.<p>The second paragraph talks about setting a #define before including a header, as if this is still the 90&#x27;s.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=nlohmann" target="_blank">nlohmann</a>   <span class="timeago" data-date="2021-08-19 12:08:56 &#43;0000 UTC">2021-08-19 12:08:56 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            I would be happy to have a different way to decide if a member variable exists or not without touching anything else.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=mike_hock" target="_blank">mike_hock</a>   <span class="timeago" data-date="2021-08-19 08:49:49 &#43;0000 UTC">2021-08-19 08:49:49 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Unfortunately, this antipattern has persisted way beyond the 90s. But, you know, if the only way the standard provides to achieve a certain goal is a shitty hack, people will use the shitty hack.
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=knorker" target="_blank">knorker</a>   <span class="timeago" data-date="2021-08-19 11:22:36 &#43;0000 UTC">2021-08-19 11:22:36 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            It&#x27;s definitely not the only way, though.<p>It can be a trade-off, but becoming less and less so. I&#x27;ll admit to not looking at the implementation, but when you sell it as &quot;modern&quot; then it&#x27;s not OK to do it for performance, for example.<p>And almost every single use I&#x27;ve seen &quot;for performance&quot; actually has zero or negligible performance impact.
        </div>
        <div class="children">
            
        </div>
    </div>


            
                


    
    <div class="comment hasChildren">
        <p><a href="https://news.ycombinator.com/user?id=a-dub" target="_blank">a-dub</a>   <span class="timeago" data-date="2021-08-19 10:27:25 &#43;0000 UTC">2021-08-19 10:27:25 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            what&#x27;s wrong with #define(s)?
        </div>
        <div class="children">
            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=einpoklum" target="_blank">einpoklum</a>   <span class="timeago" data-date="2021-08-19 11:00:31 &#43;0000 UTC">2021-08-19 11:00:31 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            The compiler is blind to them, so they can&#x27;t be reasoned about &#x2F; carried forward anywhere &#x2F; allowed for in one way or another.<p>Moreover, because of `#define`s, the effect of including a file can be entirely different, so a compiler can never say &quot;Oh, I know what&#x27;s in this include file already, I don&#x27;t need to include it again in other translation units&quot;.<p>Of course #define&#x27;s have many uses, and at present cannot be avoided entirely, but C++ has been making an effort to have other mechanisms put in place so as to obviate the use of #define&#x27;s<p>In particular, look for CppCon talks about Modules.
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


            
        </div>
    </div>


            
                


    
    <div class="comment ">
        <p><a href="https://news.ycombinator.com/user?id=quietbritishjim" target="_blank">quietbritishjim</a>   <span class="timeago" data-date="2021-08-19 11:32:00 &#43;0000 UTC">2021-08-19 11:32:00 &#43;0000 UTC</span> [ - ]</p>
        <div class="body">
            Of course you&#x27;d get your compiler to globally define that symbol rather than literally using a #define. Assuming you&#x27;re using CMake, that means using target_compile_definitions()
        </div>
        <div class="children">
            
        </div>
    </div>


            
        </div>
    </div>


        
    
</article>

    </main>
    <footer>
        <span class="h-logo">&copy; Hugo Hacker News</span><br/>
        Site created By <a href="https://davidejones.com" target="_blank">David E Jones</a> Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> and the <a href="https://github.com/HackerNews/API" target="_blank">Hacker News api</a>.
        <ul>
            
                <li><a href="/hugo-hn/guidelines/">Guidelines</a></li>
            
                <li><a href="/hugo-hn/faq/">FAQ</a></li>
            
                <li><a href="mailto:hn@ycombinator.com">Support</a></li>
            
                <li><a href="https://github.com/HackerNews/API">API</a></li>
            
                <li><a href="/hugo-hn/security/">Security</a></li>
            
                <li><a href="/hugo-hn/lists/">Lists</a></li>
            
                <li><a href="https://news.ycombinator.com/bookmarklet.html">Bookmarklet</a></li>
            
                <li><a href="/hugo-hn/dmca/">DMCA</a></li>
            
                <li><a href="http://www.ycombinator.com/apply/">Apply to YC</a></li>
            
                <li><a href="mailto:hn@ycombinator.com">Contact</a></li>
            
        </ul>
    </footer>

    
    
    
    
    
    
    <script type="text/javascript" src="https://davidejones.github.io/hugo-hn/main.01d140732eee0e8adfdb7a7f714755097c6676bfb8e8bf27645ce342b2ed12a481b08f6838c413c20bff3acf20f6159b3336339a220ff5ec5e45eb7877106361.js"  integrity="sha512-AdFAcy7uDorf23p/cUdVCXxmdr&#43;46L8nZFzjQrLtEqSBsI9oOMQTwgv/Os8g9hWbMzYzmiIP9exeRet4dxBjYQ=="  crossorigin="anonymous" defer></script>
</body>
</html>

